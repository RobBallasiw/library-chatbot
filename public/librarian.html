<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Librarian Dashboard</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #f5f7fa;
      padding: 20px;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 28px;
      margin-bottom: 8px;
    }

    .header p {
      opacity: 0.9;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .stat-card h3 {
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
    }

    .stat-card .number {
      font-size: 32px;
      font-weight: 600;
      color: #667eea;
    }

    .conversations {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .conversations-header {
      padding: 20px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .conversations-header h2 {
      font-size: 20px;
    }

    .refresh-btn {
      padding: 8px 16px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    .refresh-btn:hover {
      background: #5568d3;
    }

    .conversation-list {
      max-height: 600px;
      overflow-y: auto;
    }

    .conversation-item {
      padding: 20px;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
      transition: background 0.2s;
    }

    .conversation-item:hover {
      background: #f8f9fa;
    }

    .conversation-item.active {
      background: #f0f4ff !important;
      border-left: 4px solid #667eea !important;
    }

    .conversation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .session-id {
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }

    .status-badge {
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
    }

    .status-badge.human {
      background: #fef3c7;
      color: #92400e;
    }

    .status-badge.bot {
      background: #e9d5ff;
      color: #6b21a8;
    }

    .status-badge.viewed {
      background: #dbeafe;
      color: #1e40af;
    }

    .status-badge.responded {
      background: #dcfce7;
      color: #166534;
    }

    .status-badge.closed {
      background: #f3f4f6;
      color: #6b7280;
    }

    .conversation-preview {
      color: #666;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .conversation-time {
      color: #999;
      font-size: 12px;
    }

    .empty-state {
      padding: 60px 20px;
      text-align: center;
      color: #999;
    }

    .empty-state svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      opacity: 0.3;
    }

    /* Notification Alert */
    .notification-alert {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #fef3c7;
      border: 2px solid #f59e0b;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      z-index: 2000;
      animation: slideIn 0.3s ease-out, pulse 2s infinite;
      max-width: 400px;
    }

    #notification-bot.notification-alert {
      background: #dbeafe !important;
      border: 2px solid #3b82f6 !important;
      animation: slideIn 0.3s ease-out !important;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 10px 40px rgba(245, 158, 11, 0.3);
      }
      50% {
        box-shadow: 0 10px 40px rgba(245, 158, 11, 0.6);
      }
    }

    .notification-content {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .notification-icon {
      font-size: 32px;
      animation: ring 1s infinite;
    }

    @keyframes ring {
      0%, 100% { transform: rotate(0deg); }
      10%, 30% { transform: rotate(-10deg); }
      20%, 40% { transform: rotate(10deg); }
    }

    .notification-content strong {
      color: #92400e;
      font-size: 16px;
      display: block;
      margin-bottom: 4px;
    }

    .notification-content p {
      color: #78350f;
      font-size: 14px;
      margin: 0;
    }

    .dismiss-btn {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #92400e;
      padding: 4px;
      margin-left: auto;
    }

    .dismiss-btn:hover {
      color: #78350f;
    }

    /* User Avatar */
    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 16px;
      color: white;
      flex-shrink: 0;
    }

    .conversation-item.waiting {
      background: #fef3c7 !important;
      border-left: 4px solid #f59e0b !important;
    }

    .conversation-item.waiting:hover {
      background: #fde68a !important;
    }

    .unread-indicator {
      width: 12px;
      height: 12px;
      background: #ef4444;
      border-radius: 50%;
      border: 2px solid white;
      flex-shrink: 0;
    }

    /* Conversation Detail Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
      padding: 20px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h3 {
      font-size: 18px;
      color: #333;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #999;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
    }

    .close-btn:hover {
      background: #f0f0f0;
      color: #333;
    }

    .modal-messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      background: #f8f9fa;
    }

    .message {
      margin-bottom: 16px;
      padding: 12px 16px;
      border-radius: 8px;
      max-width: 80%;
    }

    .message.user {
      background: #e5e7eb;
      margin-right: auto;
    }

    .message.bot {
      background: #dbeafe;
      margin-right: auto;
    }

    .message.librarian {
      background: #dcfce7;
      margin-left: auto;
    }

    .message-role {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 4px;
      opacity: 0.7;
    }

    .message-content {
      font-size: 14px;
      line-height: 1.5;
    }

    .message-time {
      font-size: 11px;
      opacity: 0.6;
      margin-top: 4px;
    }

    .modal-input {
      padding: 20px;
      border-top: 1px solid #e0e0e0;
      display: flex;
      gap: 12px;
    }

    .modal-input textarea {
      flex: 1;
      padding: 12px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      resize: none;
      min-height: 60px;
    }

    .modal-input textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    .send-btn {
      padding: 12px 24px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      align-self: flex-end;
    }

    .send-btn:hover {
      background: #5568d3;
    }

    .send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .end-session-btn {
      padding: 12px 24px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    .end-session-btn:hover {
      background: #dc2626;
    }

    .end-session-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .warn-btn {
      padding: 12px 24px;
      background: #f59e0b;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    .warn-btn:hover {
      background: #d97706;
    }

    .warn-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üìö Librarian Dashboard</h1>
    <p>Monitor and respond to chat conversations</p>
    <p style="font-size: 12px; opacity: 0.8; margin-top: 8px;">üîÑ Auto-refreshes every 2 seconds</p>
  </div>

  <!-- Notification Alerts -->
  <div id="notification-librarian" class="notification-alert" style="display: none; top: 20px;">
    <div class="notification-content">
      <span class="notification-icon">üîî</span>
      <div>
        <strong>User Requesting Librarian!</strong>
        <p id="notification-librarian-text">A user wants to talk with a librarian</p>
      </div>
      <button onclick="dismissNotification('librarian')" class="dismiss-btn">‚úï</button>
    </div>
  </div>

  <div id="notification-bot" class="notification-alert notification-bot" style="display: none; top: 100px; background: #dbeafe !important; border: 2px solid #3b82f6 !important;">
    <div class="notification-content">
      <span class="notification-icon">üí¨</span>
      <div>
        <strong>Active Bot Conversations</strong>
        <p id="notification-bot-text">Users chatting with the bot</p>
      </div>
      <button onclick="dismissNotification('bot')" class="dismiss-btn">‚úï</button>
    </div>
  </div>

  <div class="stats">
    <div class="stat-card">
      <h3>Active Conversations</h3>
      <div class="number" id="active-count">0</div>
    </div>
    <div class="stat-card">
      <h3>Pending Requests</h3>
      <div class="number" id="pending-count">0</div>
    </div>
    <div class="stat-card">
      <h3>Total Messages</h3>
      <div class="number" id="message-count">0</div>
    </div>
  </div>

  <div class="conversations">
    <div class="conversations-header">
      <h2>Conversations</h2>
      <button class="refresh-btn" onclick="loadNotifications()">üîÑ Refresh</button>
    </div>
    <div class="conversation-list" id="conversation-list">
      <div class="empty-state">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
        </svg>
        <p>No active conversations</p>
      </div>
    </div>
  </div>

  <!-- Conversation Detail Modal -->
  <div class="modal" id="conversation-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="modal-title">Conversation</h3>
        <button class="close-btn" onclick="closeModal()">√ó</button>
      </div>
      <div class="modal-messages" id="modal-messages">
        <!-- Messages will be loaded here -->
      </div>
      <div class="modal-input">
        <textarea id="response-input" placeholder="Type your response..."></textarea>
        <div style="display: flex; flex-direction: column; gap: 8px;">
          <button class="send-btn" onclick="sendResponse()">Send</button>
          <button class="warn-btn" onclick="sendWarning()">Warn Before Ending</button>
          <button class="end-session-btn" onclick="endSession()">End Session</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let currentSessionId = null;
    let currentConversation = null;
    let lastNotificationCount = 0;
    let lastActiveCount = 0;
    let notificationSound = null;
    let librarianNotificationTimeout = null;
    let botNotificationTimeout = null;
    let viewedConversations = new Set(JSON.parse(localStorage.getItem('viewedConversations') || '[]')); // Track which conversations have been viewed
    let lastConversationsHash = ''; // Track if conversations changed

    // Save viewed conversations to localStorage whenever it changes
    function saveViewedConversations() {
      localStorage.setItem('viewedConversations', JSON.stringify([...viewedConversations]));
    }

    // Create notification sound
    function initNotificationSound() {
      // Create a simple beep sound using Web Audio API
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      notificationSound = () => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
      };
    }

    // Initialize on first user interaction
    document.addEventListener('click', () => {
      if (!notificationSound) initNotificationSound();
    }, { once: true });

    function getColorForSession(sessionId) {
      // Generate consistent color based on session ID
      const colors = [
        '#667eea', '#764ba2', '#f093fb', '#4facfe',
        '#43e97b', '#fa709a', '#fee140', '#30cfd0'
      ];
      const hash = sessionId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      return colors[hash % colors.length];
    }

    function getInitials(sessionId) {
      // Generate initials from session ID
      const parts = sessionId.split('_');
      return parts[parts.length - 1].substring(0, 2).toUpperCase();
    }

    function showNotification(count, type = 'librarian', playSound = true) {
      if (type === 'librarian') {
        // High priority - user requesting librarian
        const alert = document.getElementById('notification-librarian');
        const text = document.getElementById('notification-librarian-text');
        
        text.textContent = count === 1 
          ? '1 user is requesting to talk with a librarian' 
          : `${count} users are requesting to talk with a librarian`;
        
        alert.style.display = 'block';
        
        // Play sound for librarian requests (only if requested)
        if (playSound && notificationSound) {
          try {
            notificationSound();
          } catch (e) {
            console.log('Could not play sound:', e);
          }
        }
        
        // Clear previous timeout and set new one
        if (librarianNotificationTimeout) {
          clearTimeout(librarianNotificationTimeout);
        }
        // Don't auto-dismiss - let updateStats handle it based on count
        librarianNotificationTimeout = null;
      } else {
        // Low priority - bot conversations
        const alert = document.getElementById('notification-bot');
        const text = document.getElementById('notification-bot-text');
        
        text.textContent = count === 1 
          ? '1 user chatting with the bot' 
          : `${count} users chatting with the bot`;
        
        alert.style.display = 'block';
        
        // Don't auto-dismiss - let updateStats handle it based on count
        // Clear any existing timeout
        if (botNotificationTimeout) {
          clearTimeout(botNotificationTimeout);
          botNotificationTimeout = null;
        }
      }
    }

    function dismissNotification(type) {
      if (type === 'librarian') {
        const alert = document.getElementById('notification-librarian');
        alert.style.display = 'none';
        if (librarianNotificationTimeout) {
          clearTimeout(librarianNotificationTimeout);
        }
      } else {
        const alert = document.getElementById('notification-bot');
        alert.style.display = 'none';
        if (botNotificationTimeout) {
          clearTimeout(botNotificationTimeout);
        }
      }
    }

    async function loadNotifications() {
      try {
        const response = await fetch('/api/librarian/notifications');
        const data = await response.json();
        
        // Create hash of conversations to detect changes
        const conversationsHash = JSON.stringify(data.activeConversations.map(c => ({
          id: c.sessionId,
          status: c.status,
          count: c.messageCount
        })));
        
        // Only update if something changed
        if (conversationsHash !== lastConversationsHash) {
          updateStats(data);
          renderConversations(data.activeConversations);
          lastConversationsHash = conversationsHash;
        }
      } catch (error) {
        console.error('Error loading notifications:', error);
      }
    }

    function updateStats(data) {
      // Cache conversations for immediate updates
      cachedConversations = data.activeConversations;
      
      // Clean up viewed conversations - remove sessions that no longer exist
      const activeSessionIds = new Set(data.activeConversations.map(c => c.sessionId));
      const viewedArray = [...viewedConversations];
      let cleaned = false;
      viewedArray.forEach(sessionId => {
        if (!activeSessionIds.has(sessionId)) {
          viewedConversations.delete(sessionId);
          cleaned = true;
        }
      });
      if (cleaned) {
        saveViewedConversations();
      }
      
      const unreadLibrarian = data.activeConversations.filter(c => 
        c.status === 'human'
      ).length;
      
      const unreadBot = data.activeConversations.filter(c => 
        c.status === 'bot' && !viewedConversations.has(c.sessionId)
      ).length;
      
      const totalActive = data.activeConversations.length;
      const totalPending = data.activeConversations.filter(c => c.status === 'human').length;
      const totalMessages = data.activeConversations.reduce((sum, c) => sum + c.messageCount, 0);
      
      document.getElementById('active-count').textContent = totalActive;
      document.getElementById('pending-count').textContent = totalPending;
      document.getElementById('message-count').textContent = totalMessages;
      
      // Remove 'human' status conversations from viewedConversations (they need attention again)
      data.activeConversations.forEach(c => {
        if (c.status === 'human' && viewedConversations.has(c.sessionId)) {
          viewedConversations.delete(c.sessionId);
          saveViewedConversations();
        }
      });
      
      // Show notification for librarian requests (always show, regardless of viewed status)
      if (unreadLibrarian > 0) {
        // Play sound if count increased
        const shouldPlaySound = unreadLibrarian > lastNotificationCount;
        showNotification(unreadLibrarian, 'librarian', shouldPlaySound);
      } else {
        dismissNotification('librarian');
      }
      lastNotificationCount = unreadLibrarian;
      
      // Show notification for unread bot conversations
      if (unreadBot > 0) {
        showNotification(unreadBot, 'bot', false);
      } else {
        dismissNotification('bot');
      }
      
      lastActiveCount = totalActive;
    }

    function renderConversations(conversations) {
      const listEl = document.getElementById('conversation-list');
      
      if (conversations.length === 0) {
        listEl.innerHTML = `
          <div class="empty-state">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
            </svg>
            <p>No active conversations</p>
          </div>
        `;
        return;
      }

      listEl.innerHTML = conversations.map(conv => {
        const color = getColorForSession(conv.sessionId);
        const initials = getInitials(conv.sessionId);
        const isWaiting = conv.status === 'human';
        const isUnread = !viewedConversations.has(conv.sessionId) && conv.status === 'bot';
        
        return `
        <div class="conversation-item ${isWaiting ? 'waiting' : ''}" 
             data-session="${conv.sessionId}" 
             onclick="viewConversation('${conv.sessionId}')"
             style="${isWaiting ? 'background: #fef3c7 !important; border-left: 4px solid #f59e0b !important;' : ''}">
          <div class="conversation-header">
            <div style="display: flex; align-items: center; gap: 12px;">
              ${isUnread ? '<div class="unread-indicator"></div>' : ''}
              <div class="user-avatar" style="background: ${color};">${initials}</div>
              <span class="session-id">${conv.sessionId.substring(0, 20)}...</span>
            </div>
            <span class="status-badge ${conv.status}">
              ${conv.status === 'human' ? 'üü° Waiting' : conv.status === 'responded' ? '‚úÖ Responded' : conv.status === 'viewed' ? 'üëÅÔ∏è Viewed' : conv.status === 'closed' ? 'üîí Closed' : 'ü§ñ Bot'}
            </span>
          </div>
          <div class="conversation-preview">
            ${conv.lastMessage ? conv.lastMessage.content.substring(0, 80) + '...' : 'No messages yet'}
          </div>
          <div class="conversation-time">
            ${new Date(conv.startTime).toLocaleString()} ‚Ä¢ ${conv.messageCount} messages
          </div>
        </div>
      `;
      }).join('');
    }

    function viewConversation(sessionId) {
      currentSessionId = sessionId;
      const conv = document.querySelector(`[data-session="${sessionId}"]`);
      
      // Mark this conversation as viewed
      viewedConversations.add(sessionId);
      saveViewedConversations(); // Persist to localStorage
      
      // Update notification counts immediately (no API call needed)
      updateNotificationCountsImmediate();
      
      // Re-render conversations to remove red dot immediately
      if (cachedConversations && cachedConversations.length > 0) {
        renderConversations(cachedConversations);
      }
      
      // Fetch full conversation
      fetch(`/api/conversation/${sessionId}`)
        .then(res => res.json())
        .then(data => {
          currentConversation = data;
          renderConversationModal(data);
          document.getElementById('conversation-modal').classList.add('active');
          
          // Start auto-refresh for this conversation
          startConversationPolling();
        })
        .catch(error => {
          alert('Error loading conversation: ' + error.message);
        });
    }

    let cachedConversations = [];

    function updateNotificationCountsImmediate() {
      // Remove 'human' status conversations from viewedConversations (they need attention again)
      cachedConversations.forEach(c => {
        if (c.status === 'human' && viewedConversations.has(c.sessionId)) {
          viewedConversations.delete(c.sessionId);
          saveViewedConversations();
        }
      });
      
      // Use cached data to update counts immediately
      const unreadLibrarian = cachedConversations.filter(c => 
        c.status === 'human'
      ).length;
      
      const unreadBot = cachedConversations.filter(c => 
        c.status === 'bot' && !viewedConversations.has(c.sessionId)
      ).length;
      
      // Update notifications with unread counts
      if (unreadLibrarian > 0) {
        showNotification(unreadLibrarian, 'librarian');
      } else {
        dismissNotification('librarian');
      }
      
      if (unreadBot > 0) {
        showNotification(unreadBot, 'bot');
      } else {
        dismissNotification('bot');
      }
      
      // Re-render conversations to update yellow highlighting
      if (cachedConversations && cachedConversations.length > 0) {
        renderConversations(cachedConversations);
      }
    }

    let conversationPollingInterval = null;
    let endSessionTimeout = null; // Track countdown timer

    function startConversationPolling() {
      // Clear any existing polling
      if (conversationPollingInterval) {
        clearInterval(conversationPollingInterval);
      }
      
      // Do an immediate refresh
      setTimeout(refreshConversation, 100);
      
      // Then poll every 2 seconds while modal is open
      conversationPollingInterval = setInterval(() => {
        if (currentSessionId && document.getElementById('conversation-modal').classList.contains('active')) {
          refreshConversation();
        }
      }, 2000);
    }

    function stopConversationPolling() {
      if (conversationPollingInterval) {
        clearInterval(conversationPollingInterval);
        conversationPollingInterval = null;
      }
    }

    async function refreshConversation() {
      if (!currentSessionId) return;
      
      try {
        const response = await fetch(`/api/conversation/${currentSessionId}`);
        const data = await response.json();
        
        console.log('Refresh check:', {
          currentMessages: currentConversation?.messages?.length || 0,
          newMessages: data.messages?.length || 0,
          currentStatus: currentConversation?.status,
          newStatus: data.status,
          countdown: data.countdown
        });
        
        // Check if countdown was cancelled (user sent a message)
        if (endSessionTimeout && !data.countdown) {
          console.log('‚èπÔ∏è Countdown cancelled by user message');
          clearInterval(endSessionTimeout);
          endSessionTimeout = null;
          
          // Reset warn button
          const warnBtn = document.querySelector('.warn-btn');
          if (warnBtn) {
            warnBtn.textContent = 'Warn Before Ending';
            warnBtn.disabled = false;
          }
        }
        
        // Check if there are new messages or status changed
        const hasNewMessages = !currentConversation || 
                               data.messages.length !== currentConversation.messages.length ||
                               data.status !== currentConversation.status;
        
        if (hasNewMessages) {
          console.log('‚úÖ Updating conversation view');
          const messagesEl = document.getElementById('modal-messages');
          
          currentConversation = data;
          renderConversationModal(data);
          
          // Always scroll to bottom on refresh
          messagesEl.scrollTop = messagesEl.scrollHeight;
        } else {
          console.log('‚è≠Ô∏è No changes detected');
        }
      } catch (error) {
        console.error('Error refreshing conversation:', error);
      }
    }

    function renderConversationModal(conversation) {
      const titleEl = document.getElementById('modal-title');
      const messagesEl = document.getElementById('modal-messages');
      
      const statusText = conversation.status === 'human' ? 'üü° Waiting' : 
                        conversation.status === 'responded' ? '‚úÖ Responded' : 
                        conversation.status === 'viewed' ? 'üëÅÔ∏è Viewed' : 
                        conversation.status === 'closed' ? 'üîí Closed' : 'ü§ñ Bot';
      
      titleEl.textContent = `Session: ${conversation.sessionId.substring(0, 30)}... (${statusText})`;
      
      // Disable input if conversation is closed
      const responseInput = document.getElementById('response-input');
      const sendBtn = document.querySelector('.send-btn');
      const warnBtn = document.querySelector('.warn-btn');
      const endBtn = document.querySelector('.end-session-btn');
      
      if (conversation.status === 'closed') {
        responseInput.disabled = true;
        responseInput.placeholder = 'This conversation has been closed';
        sendBtn.disabled = true;
        warnBtn.disabled = true;
        endBtn.disabled = true;
      } else {
        responseInput.disabled = false;
        responseInput.placeholder = 'Type your response...';
        sendBtn.disabled = false;
        warnBtn.disabled = false;
        endBtn.disabled = false;
      }
      
      if (!conversation.messages || conversation.messages.length === 0) {
        messagesEl.innerHTML = '<div class="empty-state"><p>No messages yet</p></div>';
        return;
      }

      messagesEl.innerHTML = conversation.messages.map(msg => `
        <div class="message ${msg.role}">
          <div class="message-role">${msg.role}</div>
          <div class="message-content">${escapeHtml(msg.content)}</div>
          <div class="message-time">${new Date(msg.timestamp).toLocaleString()}</div>
        </div>
      `).join('');
      
      // Force scroll to bottom immediately
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function closeModal() {
      document.getElementById('conversation-modal').classList.remove('active');
      stopConversationPolling();
      
      // Clear any pending countdown
      if (endSessionTimeout) {
        clearInterval(endSessionTimeout);
        endSessionTimeout = null;
        
        // Reset warn button
        const warnBtn = document.querySelector('.warn-btn');
        if (warnBtn) {
          warnBtn.textContent = 'Warn Before Ending';
          warnBtn.disabled = false;
        }
      }
      
      currentSessionId = null;
      currentConversation = null;
      document.getElementById('response-input').value = '';
    }

    async function sendResponse() {
      const input = document.getElementById('response-input');
      const message = input.value.trim();
      
      if (!message || !currentSessionId) {
        return;
      }

      try {
        const response = await fetch('/api/librarian/respond', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: currentSessionId,
            message: message
          })
        });

        const data = await response.json();
        
        if (data.success) {
          input.value = '';
          // Immediately refresh to show the sent message
          refreshConversation();
        } else {
          alert('Error sending message: ' + data.error);
        }
      } catch (error) {
        alert('Error sending message: ' + error.message);
      }
    }

    async function sendWarning() {
      if (!currentSessionId) return;

      const warningMessage = "Thank you for your question! I've provided the information you need. If your inquiry has been resolved, I'll be ending this session in 10 seconds. Feel free to ask any follow-up questions now, or you can always start a new chat with the AI assistant or request a librarian again if you need more help later.";

      try {
        const response = await fetch('/api/librarian/respond', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: currentSessionId,
            message: warningMessage
          })
        });

        const data = await response.json();
        
        if (data.success) {
          // Immediately refresh to show the sent message
          refreshConversation();
          
          // Set initial countdown on server
          await fetch('/api/librarian/set-countdown', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              sessionId: currentSessionId,
              countdown: 10
            })
          });
          
          // Start 10-second countdown
          let countdown = 10;
          const warnBtn = document.querySelector('.warn-btn');
          const originalText = warnBtn.textContent;
          warnBtn.disabled = true;
          warnBtn.textContent = `Ending in ${countdown}s...`;
          
          const countdownInterval = setInterval(async () => {
            // Check if countdown was cancelled on server
            try {
              const checkResponse = await fetch(`/api/conversation/${currentSessionId}`);
              const checkData = await checkResponse.json();
              
              if (!checkData.countdown) {
                // Countdown was cancelled
                console.log('‚èπÔ∏è Countdown cancelled by server');
                clearInterval(countdownInterval);
                endSessionTimeout = null;
                warnBtn.textContent = originalText;
                warnBtn.disabled = false;
                return;
              }
            } catch (error) {
              console.error('Error checking countdown:', error);
            }
            
            countdown--;
            warnBtn.textContent = `Ending in ${countdown}s...`;
            
            // Update countdown status on server
            if (countdown > 0) {
              try {
                await fetch('/api/librarian/set-countdown', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    sessionId: currentSessionId,
                    countdown: countdown
                  })
                });
              } catch (error) {
                console.error('Error updating countdown:', error);
              }
            }
            
            if (countdown <= 0) {
              clearInterval(countdownInterval);
              endSessionTimeout = null;
              warnBtn.textContent = originalText;
              warnBtn.disabled = false;
              
              // Automatically end the session
              endSessionAutomatically();
            }
          }, 1000);
          
          // Store the interval so it can be cancelled if needed
          endSessionTimeout = countdownInterval;
        } else {
          alert('Error sending warning: ' + data.error);
        }
      } catch (error) {
        alert('Error sending warning: ' + error.message);
      }
    }

    async function endSessionAutomatically() {
      if (!currentSessionId) return;

      try {
        const response = await fetch('/api/librarian/end-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId: currentSessionId })
        });

        const data = await response.json();
        
        if (data.success) {
          closeModal();
          loadNotifications(); // Refresh the list
        } else {
          console.error('Error ending session:', data.error);
        }
      } catch (error) {
        console.error('Error ending session:', error.message);
      }
    }

    async function endSession() {
      if (!currentSessionId) return;
      
      if (!confirm('End this session? The user will be returned to the AI assistant.')) {
        return;
      }

      try {
        const response = await fetch('/api/librarian/end-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId: currentSessionId })
        });

        const data = await response.json();
        
        if (data.success) {
          alert('Session ended. User has been returned to the AI assistant.');
          closeModal();
          loadNotifications(); // Refresh the list
        } else {
          alert('Error ending session: ' + data.error);
        }
      } catch (error) {
        alert('Error ending session: ' + error.message);
      }
    }

    // Allow Enter to send (Shift+Enter for new line)
    document.addEventListener('DOMContentLoaded', () => {
      const input = document.getElementById('response-input');
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendResponse();
        }
      });
    });

    // Auto-refresh every 2 seconds
    setInterval(loadNotifications, 2000);
    
    // Initial load
    loadNotifications();
  </script>
</body>
</html>
