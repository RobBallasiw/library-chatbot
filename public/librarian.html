<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Librarian Dashboard</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f172a;
      min-height: 100vh;
      color: #e2e8f0;
      overflow-x: hidden;
    }

    /* Sidebar Layout */
    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      width: 280px;
      background: linear-gradient(180deg, #1e293b 0%, #1a2332 100%);
      border-right: 1px solid #334155;
      padding: 24px;
      display: flex;
      flex-direction: column;
      z-index: 100;
      box-shadow: 4px 0 12px rgba(0, 0, 0, 0.3);
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 32px;
      padding-bottom: 24px;
      border-bottom: 1px solid #334155;
      cursor: default;
    }

    .logo-icon {
      font-size: 32px;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% {
        transform: translateY(0px);
      }
      50% {
        transform: translateY(-5px);
      }
    }

    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7);
      }
      50% {
        box-shadow: 0 0 0 10px rgba(251, 191, 36, 0);
      }
    }

    .stat-item.has-pending {
      animation: pulse 2s infinite;
    }

    .logo-text h1 {
      font-size: 20px;
      font-weight: 800;
      color: #f1f5f9;
      margin-bottom: 2px;
    }

    .logo-text p {
      font-size: 12px;
      color: #64748b;
    }

    .stats-sidebar {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-bottom: 24px;
    }

    /* Custom scrollbar for sidebar on mobile */
    .stats-sidebar::-webkit-scrollbar {
      height: 6px;
    }

    .stats-sidebar::-webkit-scrollbar-track {
      background: #0f172a;
    }

    .stats-sidebar::-webkit-scrollbar-thumb {
      background: #475569;
      border-radius: 3px;
    }

    .stats-sidebar::-webkit-scrollbar-thumb:hover {
      background: #64748b;
    }

    .stat-item {
      background: #0f172a;
      padding: 18px;
      border-radius: 12px;
      border: 1px solid #334155;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .stat-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #3b82f6, #8b5cf6);
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.3s ease;
    }

    .stat-item:hover::before {
      transform: scaleX(1);
    }

    .stat-item:hover {
      border-color: #3b82f6;
      transform: translateX(4px);
      box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
    }

    .stat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .stat-label {
      font-size: 11px;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 600;
    }

    .stat-icon {
      font-size: 20px;
      opacity: 0.6;
    }

    .stat-value {
      font-size: 32px;
      font-weight: 800;
      color: #f1f5f9;
      margin-bottom: 8px;
      transition: all 0.3s ease;
    }

    .stat-item:hover .stat-value {
      color: #3b82f6;
      transform: scale(1.05);
    }

    .stat-progress {
      width: 100%;
      height: 4px;
      background: #1e293b;
      border-radius: 2px;
      overflow: hidden;
      margin-top: 8px;
    }

    .stat-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #8b5cf6);
      border-radius: 2px;
      transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .stat-progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .stat-change {
      font-size: 11px;
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .stat-change.positive {
      color: #10b981;
    }

    .stat-change.negative {
      color: #ef4444;
    }

    .stat-change.neutral {
      color: #64748b;
    }

    .refresh-section {
      margin-top: auto;
      padding-top: 24px;
      border-top: 1px solid #334155;
    }

    .refresh-btn-sidebar {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .refresh-btn-sidebar::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    .refresh-btn-sidebar:hover::before {
      left: 100%;
    }

    .refresh-btn-sidebar:hover {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
    }

    .refresh-btn-sidebar:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .refresh-btn-sidebar span:first-child {
      display: inline-block;
      transition: transform 0.3s ease;
    }

    .refresh-btn-sidebar:hover span:first-child {
      transform: rotate(180deg);
    }

    .auto-refresh-info {
      text-align: center;
      font-size: 11px;
      color: #64748b;
      margin-top: 12px;
    }

    /* Main Content Area */
    .main-content {
      margin-left: 280px;
      padding: 32px;
      min-height: 100vh;
    }

    .header {
      margin-bottom: 32px;
    }

    .header h1 {
      font-size: 32px;
      font-weight: 800;
      color: #f1f5f9;
      margin-bottom: 8px;
    }

    .header p {
      color: #94a3b8;
      font-size: 15px;
    }

    .stats {
      display: none; /* Hide original stats, using sidebar instead */
    }

    .stat-card {
      display: none;
    }

    .conversations {
      background: #1e293b;
      border-radius: 16px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      border: 1px solid #334155;
    }

    .conversations-header {
      padding: 28px 32px;
      border-bottom: 1px solid #334155;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #1e293b;
    }

    .conversations-header h2 {
      font-size: 24px;
      font-weight: 800;
      color: #f1f5f9;
    }

    .search-filter-bar {
      padding: 24px 32px;
      border-bottom: 1px solid #334155;
      background: #0f172a;
    }

    .search-box {
      margin-bottom: 16px;
    }

    .search-box input {
      width: 100%;
      padding: 14px 20px;
      border: 1px solid #334155;
      border-radius: 12px;
      font-size: 15px;
      transition: all 0.2s;
      background: #1e293b;
      color: #e2e8f0;
    }

    .search-box input::placeholder {
      color: #64748b;
    }

    .search-box input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      background: #1e293b;
    }

    .filter-controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .filter-controls select {
      padding: 12px 18px;
      border: 1px solid #334155;
      border-radius: 12px;
      font-size: 14px;
      background: #1e293b;
      color: #e2e8f0;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    .filter-controls select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .clear-filters-btn {
      padding: 12px 24px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
    }

    .clear-filters-btn:hover {
      background: #2563eb;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }

    .filter-badge {
      display: inline-block;
      padding: 4px 12px;
      background: #3b82f6;
      color: white;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 700;
      margin-left: 10px;
    }

    .no-results {
      padding: 60px 20px;
      text-align: center;
      color: #999;
    }

    .no-results svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      opacity: 0.3;
    }

    .highlight {
      background: #3b82f6;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
    }

    .refresh-btn {
      display: none; /* Using sidebar refresh button instead */
    }

    .conversation-list {
      max-height: 600px;
      overflow-y: auto;
    }

    /* Custom scrollbar for dark theme */
    .conversation-list::-webkit-scrollbar {
      width: 8px;
    }

    .conversation-list::-webkit-scrollbar-track {
      background: #0f172a;
    }

    .conversation-list::-webkit-scrollbar-thumb {
      background: #475569;
      border-radius: 4px;
    }

    .conversation-list::-webkit-scrollbar-thumb:hover {
      background: #64748b;
    }

    .conversation-item {
      padding: 24px 32px;
      border-bottom: 1px solid #334155;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      background: #1e293b;
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .conversation-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 3px;
      background: transparent;
      transition: all 0.3s ease;
    }

    .conversation-item:hover {
      background: #334155;
      transform: translateX(4px);
    }

    .conversation-item:hover::before {
      background: #3b82f6;
      width: 4px;
    }

    .conversation-item.active {
      background: #334155 !important;
    }

    .conversation-item.active::before {
      background: #3b82f6 !important;
    }

    .conversation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .session-id {
      font-weight: 600;
      color: #f1f5f9;
      font-size: 15px;
    }

    .status-badge {
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
    }

    .status-badge.human {
      background: #f59e0b;
      color: white;
    }

    .status-badge.bot {
      background: #8b5cf6;
      color: white;
    }

    .status-badge.viewed {
      background: #3b82f6;
      color: white;
    }

    .status-badge.responded {
      background: #10b981;
      color: white;
    }

    .status-badge.closed {
      background: #64748b;
      color: white;
    }

    .conversation-preview {
      color: #94a3b8;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .conversation-time {
      color: #64748b;
      font-size: 12px;
    }

    .empty-state {
      padding: 60px 20px;
      text-align: center;
      color: #64748b;
    }

    .empty-state p {
      color: #94a3b8;
      font-size: 16px;
    }

    .empty-state svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      opacity: 0.3;
      stroke: #475569;
    }

    .no-results {
      padding: 60px 20px;
      text-align: center;
      color: #64748b;
    }

    .no-results p {
      color: #94a3b8;
      font-size: 16px;
      margin-bottom: 12px;
    }

    .no-results svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      opacity: 0.3;
      stroke: #475569;
    }

    /* Notification Alert */
    .notification-alert {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #1e293b;
      border: 2px solid #f59e0b;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      z-index: 2000;
      animation: slideIn 0.3s ease-out, pulse 2s infinite;
      max-width: 400px;
    }

    #notification-bot.notification-alert {
      background: #1e293b !important;
      border: 2px solid #3b82f6 !important;
      animation: slideIn 0.3s ease-out !important;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 10px 40px rgba(245, 158, 11, 0.4);
      }
      50% {
        box-shadow: 0 10px 40px rgba(245, 158, 11, 0.7);
      }
    }

    .notification-content {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .notification-icon {
      font-size: 32px;
      animation: ring 1s infinite;
    }

    @keyframes ring {
      0%, 100% { transform: rotate(0deg); }
      10%, 30% { transform: rotate(-10deg); }
      20%, 40% { transform: rotate(10deg); }
    }

    .notification-content strong {
      color: #f1f5f9;
      font-size: 16px;
      display: block;
      margin-bottom: 4px;
    }

    .notification-content p {
      color: #94a3b8;
      font-size: 14px;
      margin: 0;
    }

    .dismiss-btn {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #94a3b8;
      padding: 4px;
      margin-left: auto;
      transition: color 0.2s;
    }

    .dismiss-btn:hover {
      color: #f1f5f9;
    }

    /* User Avatar */
    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 16px;
      color: white;
      flex-shrink: 0;
    }

    .conversation-item.waiting {
      background: rgba(245, 158, 11, 0.1) !important;
      border-left: 3px solid #f59e0b;
    }

    .conversation-item.waiting .session-id {
      color: #fbbf24 !important;
    }

    .conversation-item.waiting .conversation-preview {
      color: #fcd34d !important;
    }

    .conversation-item.waiting .conversation-time {
      color: #fbbf24 !important;
    }

    .conversation-item.waiting::before {
      background: #f59e0b !important;
    }

    .conversation-item.waiting:hover {
      background: rgba(245, 158, 11, 0.15) !important;
    }

    .conversation-item.waiting.active {
      background: rgba(245, 158, 11, 0.2) !important;
    }

    .unread-indicator {
      width: 10px;
      height: 10px;
      background: #ef4444;
      border-radius: 50%;
      border: 2px solid #1e293b;
      flex-shrink: 0;
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
      animation: pulse-dot 2s infinite;
    }

    @keyframes pulse-dot {
      0%, 100% {
        box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
      }
      50% {
        box-shadow: 0 0 16px rgba(239, 68, 68, 1);
      }
    }

    /* Conversation Detail Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .modal.active {
      display: flex;
      animation: fadeIn 0.3s ease forwards;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    .modal-content {
      background: #1e293b;
      border-radius: 16px;
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5);
      border: 1px solid #334155;
      animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes slideUp {
      from {
        transform: translateY(30px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .modal-header {
      padding: 24px 32px;
      border-bottom: 1px solid #334155;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #1e293b;
    }

    .modal-header h3 {
      font-size: 18px;
      color: #f1f5f9;
      font-weight: 700;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 28px;
      cursor: pointer;
      color: #64748b;
      padding: 0;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      transition: all 0.2s;
    }

    .close-btn:hover {
      background: #334155;
      color: #f1f5f9;
    }

    .modal-messages {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      background: #0f172a;
    }

    /* Custom scrollbar for modal messages */
    .modal-messages::-webkit-scrollbar {
      width: 8px;
    }

    .modal-messages::-webkit-scrollbar-track {
      background: #0f172a;
    }

    .modal-messages::-webkit-scrollbar-thumb {
      background: #475569;
      border-radius: 4px;
    }

    .modal-messages::-webkit-scrollbar-thumb:hover {
      background: #64748b;
    }

    .message {
      margin-bottom: 16px;
      padding: 14px 18px;
      border-radius: 14px;
      max-width: 80%;
      border: 1px solid #334155;
    }

    .message.user {
      background: #1e293b;
      margin-right: auto;
      border-color: #475569;
    }

    .message.bot {
      background: #1e3a5f;
      margin-right: auto;
      border-color: #3b82f6;
    }

    .message.librarian {
      background: #1e3a2f;
      margin-left: auto;
      border-color: #10b981;
    }

    .message-role {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 4px;
      color: #94a3b8;
    }

    .message-content {
      font-size: 14px;
      line-height: 1.5;
      color: #e2e8f0;
    }

    .message-time {
      font-size: 11px;
      color: #64748b;
      margin-top: 4px;
    }

    /* Typing indicator in modal */
    .typing-indicator-msg {
      padding: 12px 18px;
      border-radius: 14px;
      max-width: 80%;
      border: 1px solid #334155;
      background: #1e293b;
      margin-right: auto;
    }

    .typing-dots {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .typing-label {
      font-size: 12px;
      color: #94a3b8;
      font-weight: 500;
    }

    .typing-dots .dot {
      width: 6px;
      height: 6px;
      background: #3b82f6;
      border-radius: 50%;
      animation: typingBounce 1.4s infinite;
    }

    .typing-dots .dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-dots .dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    .typing-dots .dot:nth-child(4) {
      animation-delay: 0.6s;
    }

    @keyframes typingBounce {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-6px); }
    }

    .modal-input {
      padding: 20px 32px;
      border-top: 1px solid #334155;
      display: flex;
      gap: 14px;
      background: #1e293b;
    }

    .modal-input textarea {
      flex: 1;
      padding: 14px 16px;
      border: 1px solid #334155;
      border-radius: 12px;
      font-family: inherit;
      font-size: 14px;
      resize: none;
      min-height: 60px;
      transition: all 0.2s;
      background: #0f172a;
      color: #e2e8f0;
    }

    .modal-input textarea::placeholder {
      color: #64748b;
    }

    .modal-input textarea:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .send-btn {
      padding: 14px 28px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      align-self: flex-end;
      transition: all 0.2s;
    }

    .send-btn:hover {
      background: #2563eb;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }

    .send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .end-session-btn {
      padding: 14px 28px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
    }

    .end-session-btn:hover {
      background: #dc2626;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
    }

    .end-session-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .warn-btn {
      padding: 14px 28px;
      background: #f59e0b;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
    }

    .warn-btn:hover {
      background: #d97706;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
    }

    .warn-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Quick Replies */
    .quick-replies {
      padding: 16px 32px;
      border-top: 1px solid #334155;
      background: #1e293b;
    }

    .quick-replies-label {
      font-size: 13px;
      font-weight: 700;
      color: #94a3b8;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .quick-reply-buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .quick-reply-btn {
      padding: 12px 14px;
      background: #334155;
      border: 1px solid #475569;
      border-radius: 12px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      color: #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
      position: relative;
      z-index: 1;
    }

    .quick-reply-btn.dropdown-open {
      z-index: 2001;
    }

    .quick-reply-btn:hover {
      background: #475569;
      border-color: #3b82f6;
      transform: translateY(-1px);
    }

    .quick-reply-btn:active {
      transform: translateY(0);
    }

    .quick-reply-dropdown {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      min-width: 280px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      z-index: 2000;
      max-height: 320px;
      overflow-y: auto;
      display: none;
    }

    /* Custom scrollbar for quick reply dropdown */
    .quick-reply-dropdown::-webkit-scrollbar {
      width: 6px;
    }

    .quick-reply-dropdown::-webkit-scrollbar-track {
      background: #0f172a;
      border-radius: 12px;
    }

    .quick-reply-dropdown::-webkit-scrollbar-thumb {
      background: #475569;
      border-radius: 3px;
    }

    .quick-reply-dropdown::-webkit-scrollbar-thumb:hover {
      background: #64748b;
    }

    .quick-reply-dropdown.active {
      display: block;
      animation: slideDown 0.2s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .quick-reply-option {
      padding: 14px 18px;
      cursor: pointer;
      border-bottom: 1px solid #334155;
      transition: all 0.2s;
    }

    .quick-reply-option:last-child {
      border-bottom: none;
    }

    .quick-reply-option:hover {
      background: #334155;
    }

    .quick-reply-option-name {
      font-size: 14px;
      font-weight: 600;
      color: #f1f5f9;
      margin-bottom: 4px;
    }

    .quick-reply-option-preview {
      font-size: 12px;
      color: #94a3b8;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Mobile Responsiveness */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .header {
        padding: 20px;
      }

      .header h1 {
        font-size: 22px;
      }

      .stats {
        grid-template-columns: 1fr;
      }

      .quick-reply-buttons {
        grid-template-columns: repeat(2, 1fr);
      }

      .modal-content {
        width: 95%;
        max-height: 95vh;
      }

      .modal-input {
        flex-direction: column;
      }

      .modal-input textarea {
        min-height: 80px;
      }

      .conversation-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }

      .notification-alert {
        right: 10px;
        left: 10px;
        max-width: none;
      }

      .filter-controls {
        flex-direction: column;
      }

      .filter-controls select,
      .clear-filters-btn {
        width: 100%;
      }

      /* Mobile sidebar */
      .sidebar {
        width: 100%;
        position: relative;
        border-right: none;
        border-bottom: 1px solid #334155;
      }

      .main-content {
        margin-left: 0;
        padding: 16px;
      }

      .stats-sidebar {
        flex-direction: row;
        overflow-x: auto;
      }

      .stat-item {
        min-width: 140px;
      }
    }
  </style>
</head>
<body>
  <!-- Sidebar -->
  <div class="sidebar">
    <div class="logo">
      <div class="logo-icon">üìö</div>
      <div class="logo-text">
        <h1>Librarian</h1>
        <p>Dashboard</p>
      </div>
    </div>

    <div class="stats-sidebar">
      <div class="stat-item">
        <div class="stat-header">
          <div class="stat-label">Active</div>
          <div class="stat-icon">üí¨</div>
        </div>
        <div class="stat-value" id="active-count-sidebar">0</div>
        <div class="stat-progress">
          <div class="stat-progress-bar" id="active-progress" style="width: 0%"></div>
        </div>
      </div>
      <div class="stat-item">
        <div class="stat-header">
          <div class="stat-label">Pending</div>
          <div class="stat-icon">‚è≥</div>
        </div>
        <div class="stat-value" id="pending-count-sidebar">0</div>
        <div class="stat-progress">
          <div class="stat-progress-bar" id="pending-progress" style="width: 0%"></div>
        </div>
      </div>
      <div class="stat-item">
        <div class="stat-header">
          <div class="stat-label">Messages</div>
          <div class="stat-icon">üì®</div>
        </div>
        <div class="stat-value" id="message-count-sidebar">0</div>
        <div class="stat-progress">
          <div class="stat-progress-bar" id="message-progress" style="width: 0%"></div>
        </div>
      </div>
    </div>

    <div class="refresh-section">
      <button class="refresh-btn-sidebar" onclick="loadNotifications()">
        <span>üîÑ</span>
        <span>Refresh Now</span>
      </button>
      <div class="auto-refresh-info">Auto-refreshes every 2s</div>
    </div>
  </div>

  <!-- Main Content -->
  <div class="main-content">
    <div class="header">
      <h1>Conversations</h1>
      <p>Monitor and respond to chat conversations</p>
    </div>

  <!-- Notification Alerts -->
  <div id="notification-librarian" class="notification-alert" style="display: none; top: 20px;">
    <div class="notification-content">
      <span class="notification-icon">üîî</span>
      <div>
        <strong>User Requesting Librarian!</strong>
        <p id="notification-librarian-text">A user wants to talk with a librarian</p>
      </div>
      <button onclick="dismissNotification('librarian')" class="dismiss-btn">‚úï</button>
    </div>
  </div>

  <div id="notification-bot" class="notification-alert notification-bot" style="display: none; top: 100px; background: #dbeafe !important; border: 2px solid #3b82f6 !important;">
    <div class="notification-content">
      <span class="notification-icon">üí¨</span>
      <div>
        <strong>Active Bot Conversations</strong>
        <p id="notification-bot-text">Users chatting with the bot</p>
      </div>
      <button onclick="dismissNotification('bot')" class="dismiss-btn">‚úï</button>
    </div>
  </div>

  <div class="conversations">
    <div class="conversations-header">
      <h2>All Conversations</h2>
    </div>
    
    <!-- Search and Filter Controls -->
    <div class="search-filter-bar">
      <div class="search-box">
        <input type="text" id="search-input" placeholder="üîç Search conversations..." oninput="debouncedFilterConversations()">
      </div>
      <div class="filter-controls">
        <select id="status-filter" onchange="filterConversations()">
          <option value="all">All Status</option>
          <option value="bot">Bot</option>
          <option value="human">Waiting</option>
          <option value="responded">Responded</option>
          <option value="viewed">Viewed</option>
          <option value="closed">Closed</option>
        </select>
        <select id="sort-by" onchange="filterConversations()">
          <option value="newest">Newest First</option>
          <option value="oldest">Oldest First</option>
          <option value="most-messages">Most Messages</option>
          <option value="least-messages">Least Messages</option>
        </select>
        <button class="clear-filters-btn" onclick="clearFilters()">Clear Filters</button>
      </div>
    </div>
    
    <div class="conversation-list" id="conversation-list">
      <div class="empty-state">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
        </svg>
        <p>No active conversations</p>
      </div>
    </div>
  </div>
  </div> <!-- End main-content -->

  <!-- Conversation Detail Modal -->
  <div class="modal" id="conversation-modal">
    <div class="modal-content">
      <div class="modal-header">
        <div style="display: flex; align-items: center; gap: 12px;">
          <h3 id="modal-title">Conversation</h3>
          <div id="sentiment-indicator" style="display: none; padding: 6px 12px; border-radius: 20px; font-size: 14px; font-weight: 500;">
            <!-- Sentiment will be shown here -->
          </div>
        </div>
        <button class="close-btn" onclick="closeModal()">√ó</button>
      </div>
      <div class="modal-messages" id="modal-messages">
        <!-- Messages will be loaded here -->
      </div>
      <div class="quick-replies">
        <div class="quick-replies-label">üí¨ Quick Replies:</div>
        <div class="quick-reply-buttons" id="quick-reply-buttons">
          <!-- Quick reply buttons will be loaded here -->
        </div>
      </div>
      <div class="modal-input">
        <textarea id="response-input" placeholder="Type your response..."></textarea>
        <div style="display: flex; flex-direction: column; gap: 8px;">
          <button class="send-btn" onclick="sendResponse()">Send</button>
          <button class="warn-btn" onclick="sendWarning()">Warn Before Ending</button>
          <button class="end-session-btn" onclick="endSession()">End Session</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let currentSessionId = null;
    let currentConversation = null;
    let lastNotificationCount = 0;
    let lastActiveCount = 0;
    let notificationSound = null;
    let librarianNotificationTimeout = null;
    let botNotificationTimeout = null;
    let viewedConversations = new Set(JSON.parse(localStorage.getItem('viewedConversations') || '[]')); // Track which conversations have been viewed
    let lastConversationsHash = ''; // Track if conversations changed

    // Save viewed conversations to localStorage whenever it changes
    function saveViewedConversations() {
      localStorage.setItem('viewedConversations', JSON.stringify([...viewedConversations]));
    }

    // Create notification sound
    function initNotificationSound() {
      // Create a simple beep sound using Web Audio API
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      notificationSound = () => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
      };
    }

    // Initialize on first user interaction
    document.addEventListener('click', () => {
      if (!notificationSound) initNotificationSound();
    }, { once: true });

    function getColorForSession(sessionId) {
      // Generate consistent color based on session ID
      const colors = [
        '#667eea', '#764ba2', '#f093fb', '#4facfe',
        '#43e97b', '#fa709a', '#fee140', '#30cfd0',
        '#a8edea', '#fed6e3', '#fbc2eb', '#a6c1ee'
      ];
      let hash = 0;
      for (let i = 0; i < sessionId.length; i++) {
        hash = sessionId.charCodeAt(i) + ((hash << 5) - hash);
      }
      return colors[Math.abs(hash) % colors.length];
    }

    function getInitials(sessionId) {
      // Generate initials from session ID
      const parts = sessionId.split('-');
      if (parts.length >= 2) {
        return (parts[0][0] + parts[1][0]).toUpperCase();
      }
      return sessionId.substring(0, 2).toUpperCase();
    }
    
    function generateAvatar(sessionId) {
      // Use DiceBear API for consistent avatars
      const style = 'avataaars';
      return `https://api.dicebear.com/7.x/${style}/svg?seed=${sessionId}&backgroundColor=b6e3f4,c0aede,d1d4f9`;
    }

    function showNotification(count, type = 'librarian', playSound = true) {
      if (type === 'librarian') {
        // High priority - user requesting librarian
        const alert = document.getElementById('notification-librarian');
        const text = document.getElementById('notification-librarian-text');
        
        text.textContent = count === 1 
          ? '1 user is requesting to talk with a librarian' 
          : `${count} users are requesting to talk with a librarian`;
        
        alert.style.display = 'block';
        
        // Play sound for librarian requests (only if requested)
        if (playSound && notificationSound) {
          try {
            notificationSound();
          } catch (e) {
            console.log('Could not play sound:', e);
          }
        }
        
        // Clear previous timeout and set new one
        if (librarianNotificationTimeout) {
          clearTimeout(librarianNotificationTimeout);
        }
        // Don't auto-dismiss - let updateStats handle it based on count
        librarianNotificationTimeout = null;
      } else {
        // Low priority - bot conversations
        const alert = document.getElementById('notification-bot');
        const text = document.getElementById('notification-bot-text');
        
        text.textContent = count === 1 
          ? '1 user chatting with the bot' 
          : `${count} users chatting with the bot`;
        
        alert.style.display = 'block';
        
        // Don't auto-dismiss - let updateStats handle it based on count
        // Clear any existing timeout
        if (botNotificationTimeout) {
          clearTimeout(botNotificationTimeout);
          botNotificationTimeout = null;
        }
      }
    }

    function dismissNotification(type) {
      if (type === 'librarian') {
        const alert = document.getElementById('notification-librarian');
        alert.style.display = 'none';
        if (librarianNotificationTimeout) {
          clearTimeout(librarianNotificationTimeout);
        }
      } else {
        const alert = document.getElementById('notification-bot');
        alert.style.display = 'none';
        if (botNotificationTimeout) {
          clearTimeout(botNotificationTimeout);
        }
      }
    }

    // Animation helper functions
    function animateStatValue(elementId, targetValue) {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      const currentValue = parseInt(element.textContent) || 0;
      if (currentValue === targetValue) return;
      
      const duration = 600;
      const steps = 30;
      const stepValue = (targetValue - currentValue) / steps;
      const stepDuration = duration / steps;
      
      let currentStep = 0;
      const interval = setInterval(() => {
        currentStep++;
        const newValue = Math.round(currentValue + (stepValue * currentStep));
        element.textContent = newValue;
        
        if (currentStep >= steps) {
          element.textContent = targetValue;
          clearInterval(interval);
          
          // Add pulse effect on change
          element.style.transform = 'scale(1.1)';
          setTimeout(() => {
            element.style.transform = 'scale(1)';
          }, 200);
        }
      }, stepDuration);
    }

    function updateProgressBar(elementId, percentage) {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      // Cap at 100%
      const cappedPercentage = Math.min(percentage, 100);
      element.style.width = cappedPercentage + '%';
    }

    async function loadNotifications() {
      try {
        const response = await fetch('/api/librarian/notifications');
        const data = await response.json();
        
        // Create hash of conversations to detect changes
        const conversationsHash = JSON.stringify(data.activeConversations.map(c => ({
          id: c.sessionId,
          status: c.status,
          count: c.messageCount
        })));
        
        // Only update if something changed
        if (conversationsHash !== lastConversationsHash) {
          updateStats(data);
          
          // Store all conversations for filtering
          allConversations = data.activeConversations;
          
          // Apply current filters
          filterConversations();
          
          lastConversationsHash = conversationsHash;
        }
      } catch (error) {
        console.error('Error loading notifications:', error);
      }
    }

    function updateStats(data) {
      // Cache conversations for immediate updates
      cachedConversations = data.activeConversations;
      
      // Clean up viewed conversations - remove sessions that no longer exist
      const activeSessionIds = new Set(data.activeConversations.map(c => c.sessionId));
      const viewedArray = [...viewedConversations];
      let cleaned = false;
      viewedArray.forEach(sessionId => {
        if (!activeSessionIds.has(sessionId)) {
          viewedConversations.delete(sessionId);
          cleaned = true;
        }
      });
      if (cleaned) {
        saveViewedConversations();
      }
      
      const unreadLibrarian = data.activeConversations.filter(c => 
        c.status === 'human'
      ).length;
      
      const unreadBot = data.activeConversations.filter(c => 
        c.status === 'bot' && !viewedConversations.has(c.sessionId)
      ).length;
      
      const totalActive = data.activeConversations.length;
      const totalPending = data.activeConversations.filter(c => c.status === 'human').length;
      const totalMessages = data.activeConversations.reduce((sum, c) => sum + c.messageCount, 0);
      
      // Animate stat changes
      animateStatValue('active-count-sidebar', totalActive);
      animateStatValue('pending-count-sidebar', totalPending);
      animateStatValue('message-count-sidebar', totalMessages);
      
      // Update progress bars
      const maxConversations = 50; // Arbitrary max for visualization
      const maxMessages = 500;
      updateProgressBar('active-progress', (totalActive / maxConversations) * 100);
      updateProgressBar('pending-progress', totalPending > 0 ? (totalPending / totalActive) * 100 : 0);
      updateProgressBar('message-progress', (totalMessages / maxMessages) * 100);
      
      // Add pulse animation to pending stat if there are pending conversations
      const pendingStatItem = document.getElementById('pending-count-sidebar')?.closest('.stat-item');
      if (pendingStatItem) {
        if (totalPending > 0) {
          pendingStatItem.classList.add('has-pending');
        } else {
          pendingStatItem.classList.remove('has-pending');
        }
      }
      
      // Update old stats (hidden but keep for compatibility)
      const activeCountEl = document.getElementById('active-count');
      const pendingCountEl = document.getElementById('pending-count');
      const messageCountEl = document.getElementById('message-count');
      if (activeCountEl) activeCountEl.textContent = totalActive;
      if (pendingCountEl) pendingCountEl.textContent = totalPending;
      if (messageCountEl) messageCountEl.textContent = totalMessages;
      
      // Remove 'human' status conversations from viewedConversations (they need attention again)
      data.activeConversations.forEach(c => {
        if (c.status === 'human' && viewedConversations.has(c.sessionId)) {
          viewedConversations.delete(c.sessionId);
          saveViewedConversations();
        }
      });
      
      // Show notification for librarian requests (always show, regardless of viewed status)
      if (unreadLibrarian > 0) {
        // Play sound if count increased
        const shouldPlaySound = unreadLibrarian > lastNotificationCount;
        showNotification(unreadLibrarian, 'librarian', shouldPlaySound);
      } else {
        dismissNotification('librarian');
      }
      lastNotificationCount = unreadLibrarian;
      
      // Show notification for unread bot conversations
      if (unreadBot > 0) {
        showNotification(unreadBot, 'bot', false);
      } else {
        dismissNotification('bot');
      }
      
      lastActiveCount = totalActive;
    }

    // Store original conversations for filtering
    let allConversations = [];
    let filteredConversations = [];
    let filterDebounceTimer = null;

    // Debounced filter function
    function debouncedFilterConversations() {
      if (filterDebounceTimer) {
        clearTimeout(filterDebounceTimer);
      }
      filterDebounceTimer = setTimeout(filterConversations, 300);
    }

    // Filter conversations based on search and filters
    function filterConversations() {
      const searchQuery = document.getElementById('search-input').value.toLowerCase();
      const statusFilter = document.getElementById('status-filter').value;
      const sortBy = document.getElementById('sort-by').value;

      // Start with all conversations
      let filtered = [...allConversations];

      // Apply search filter
      if (searchQuery) {
        filtered = filtered.filter(conv => {
          const sessionMatch = conv.sessionId.toLowerCase().includes(searchQuery);
          const messageMatch = conv.lastMessage && conv.lastMessage.content.toLowerCase().includes(searchQuery);
          return sessionMatch || messageMatch;
        });
      }

      // Apply status filter
      if (statusFilter !== 'all') {
        filtered = filtered.filter(conv => conv.status === statusFilter);
      }

      // Apply sorting
      filtered.sort((a, b) => {
        switch (sortBy) {
          case 'newest':
            return new Date(b.startTime) - new Date(a.startTime);
          case 'oldest':
            return new Date(a.startTime) - new Date(b.startTime);
          case 'most-messages':
            return b.messageCount - a.messageCount;
          case 'least-messages':
            return a.messageCount - b.messageCount;
          default:
            return 0;
        }
      });

      filteredConversations = filtered;
      renderConversations(filtered, searchQuery);
      
      // Update header with filter count
      updateFilterBadge(filtered.length, allConversations.length);
    }

    // Clear all filters
    function clearFilters() {
      document.getElementById('search-input').value = '';
      document.getElementById('status-filter').value = 'all';
      document.getElementById('sort-by').value = 'newest';
      filterConversations();
    }

    // Update filter badge
    function updateFilterBadge(filteredCount, totalCount) {
      const header = document.querySelector('.conversations-header h2');
      const existingBadge = header.querySelector('.filter-badge');
      
      if (existingBadge) {
        existingBadge.remove();
      }
      
      if (filteredCount < totalCount) {
        const badge = document.createElement('span');
        badge.className = 'filter-badge';
        badge.textContent = `${filteredCount} of ${totalCount}`;
        header.appendChild(badge);
      }
    }

    // Highlight search terms
    function highlightText(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${query})`, 'gi');
      return text.replace(regex, '<span class="highlight">$1</span>');
    }

    function renderConversations(conversations, searchQuery = '') {
      const listEl = document.getElementById('conversation-list');
      
      if (conversations.length === 0) {
        // Check if it's because of filters
        const hasFilters = document.getElementById('search-input').value || 
                          document.getElementById('status-filter').value !== 'all';
        
        if (hasFilters) {
          listEl.innerHTML = `
            <div class="no-results">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
              </svg>
              <p>No conversations match your filters</p>
              <button class="clear-filters-btn" onclick="clearFilters()" style="margin-top: 12px;">Clear Filters</button>
            </div>
          `;
        } else {
          listEl.innerHTML = `
            <div class="empty-state">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
              </svg>
              <p>No active conversations</p>
            </div>
          `;
        }
        return;
      }

      listEl.innerHTML = conversations.map(conv => {
        const color = getColorForSession(conv.sessionId);
        const initials = getInitials(conv.sessionId);
        const avatarUrl = generateAvatar(conv.sessionId);
        const isWaiting = conv.status === 'human';
        const isUnread = !viewedConversations.has(conv.sessionId) && conv.status === 'bot';
        
        // Highlight search terms
        const sessionIdDisplay = searchQuery ? 
          highlightText(conv.sessionId.substring(0, 20), searchQuery) : 
          conv.sessionId.substring(0, 20);
        
        const previewText = conv.lastMessage ? conv.lastMessage.content.substring(0, 80) : 'No messages yet';
        const previewDisplay = searchQuery ? 
          highlightText(previewText, searchQuery) : 
          previewText;
        
        return `
        <div class="conversation-item ${isWaiting ? 'waiting' : ''} ${isUnread ? 'unread' : ''}" 
             data-session="${conv.sessionId}" 
             onclick="viewConversation('${conv.sessionId}')"
             style="${isWaiting ? 'background: #fef3c7 !important; border-left: 4px solid #f59e0b !important;' : isUnread ? 'background: #dbeafe !important; border-left: 4px solid #3b82f6 !important;' : ''}">
          <div class="conversation-header">
            <div style="display: flex; align-items: center; gap: 12px;">
              ${isUnread ? '<div class="unread-indicator"></div>' : ''}
              <div class="user-avatar" style="background: ${color}; position: relative; overflow: hidden;">
                <img src="${avatarUrl}" alt="User" style="width: 100%; height: 100%; object-fit: cover; position: relative; z-index: 1;" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                <span style="position: absolute; inset: 0; display: none; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 16px; z-index: 0;">${initials}</span>
              </div>
              <span class="session-id" style="${isUnread ? 'color: #1e40af !important;' : ''}">${sessionIdDisplay}...</span>
            </div>
            <span class="status-badge ${conv.status}">
              ${conv.status === 'human' ? 'üü° Waiting' : conv.status === 'responded' ? '‚úÖ Responded' : conv.status === 'viewed' ? 'üëÅÔ∏è Viewed' : conv.status === 'closed' ? 'üîí Closed' : 'ü§ñ Bot'}
            </span>
          </div>
          <div class="conversation-preview" style="${isUnread ? 'color: #1e40af !important;' : ''}">
            ${previewDisplay}${previewText.length > 80 ? '...' : ''}
          </div>
          <div class="conversation-time">
            ${new Date(conv.startTime).toLocaleString()} ‚Ä¢ ${conv.messageCount} messages
          </div>
        </div>
      `;
      }).join('');
    }

    function viewConversation(sessionId) {
      currentSessionId = sessionId;
      const conv = document.querySelector(`[data-session="${sessionId}"]`);
      
      // Mark this conversation as viewed
      viewedConversations.add(sessionId);
      saveViewedConversations(); // Persist to localStorage
      
      // Update notification counts immediately (no API call needed)
      updateNotificationCountsImmediate();
      
      // Re-render conversations to remove red dot immediately
      if (cachedConversations && cachedConversations.length > 0) {
        renderConversations(cachedConversations);
      }
      
      // Fetch full conversation
      fetch(`/api/conversation/${sessionId}`)
        .then(res => res.json())
        .then(data => {
          currentConversation = data;
          renderConversationModal(data);
          document.getElementById('conversation-modal').classList.add('active');
          
          // Start auto-refresh for this conversation
          startConversationPolling();
        })
        .catch(error => {
          alert('Error loading conversation: ' + error.message);
        });
    }

    let cachedConversations = [];

    function updateNotificationCountsImmediate() {
      // Don't automatically remove 'human' status from viewedConversations
      // Only remove if there are NEW messages since last view
      // This prevents the red dot from reappearing just because status changed
      
      // Use cached data to update counts immediately
      const unreadLibrarian = cachedConversations.filter(c => 
        c.status === 'human'
      ).length;
      
      const unreadBot = cachedConversations.filter(c => 
        c.status === 'bot' && !viewedConversations.has(c.sessionId)
      ).length;
      
      // Update notifications with unread counts
      if (unreadLibrarian > 0) {
        showNotification(unreadLibrarian, 'librarian');
      } else {
        dismissNotification('librarian');
      }
      
      if (unreadBot > 0) {
        showNotification(unreadBot, 'bot');
      } else {
        dismissNotification('bot');
      }
      
      // Re-render conversations to update yellow highlighting
      if (cachedConversations && cachedConversations.length > 0) {
        renderConversations(cachedConversations);
      }
    }

    let conversationPollingInterval = null;
    let endSessionTimeout = null; // Track countdown timer
    let cannedResponsesData = null; // Store canned responses

    // Load canned responses
    async function loadCannedResponses() {
      try {
        const response = await fetch('/api/canned-responses');
        cannedResponsesData = await response.json();
        renderQuickReplyButtons();
      } catch (error) {
        console.error('Error loading canned responses:', error);
      }
    }

    // Render quick reply buttons
    function renderQuickReplyButtons() {
      const container = document.getElementById('quick-reply-buttons');
      if (!cannedResponsesData || !cannedResponsesData.categories) return;
      
      container.innerHTML = cannedResponsesData.categories.map(category => `
        <div class="quick-reply-btn" data-category="${category.id}">
          <span>${category.icon}</span>
          <span>${category.name}</span>
          <div class="quick-reply-dropdown" id="dropdown-${category.id}">
            ${category.templates.map(template => `
              <div class="quick-reply-option" data-template-id="${template.id}" data-category-id="${category.id}">
                <div class="quick-reply-option-name">${template.name}</div>
                <div class="quick-reply-option-preview">${template.text.substring(0, 60)}...</div>
              </div>
            `).join('')}
          </div>
        </div>
      `).join('');
      
      // Add click handlers
      document.querySelectorAll('.quick-reply-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const categoryId = btn.dataset.category;
          const dropdown = document.getElementById(`dropdown-${categoryId}`);
          
          // Close all other dropdowns and remove dropdown-open class
          document.querySelectorAll('.quick-reply-dropdown').forEach(d => {
            if (d !== dropdown) d.classList.remove('active');
          });
          document.querySelectorAll('.quick-reply-btn').forEach(b => {
            if (b !== btn) b.classList.remove('dropdown-open');
          });
          
          // Toggle this dropdown
          dropdown.classList.toggle('active');
          btn.classList.toggle('dropdown-open');
        });
      });
      
      // Add template click handlers
      document.querySelectorAll('.quick-reply-option').forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          const categoryId = option.dataset.categoryId;
          const templateId = option.dataset.templateId;
          insertTemplate(categoryId, templateId);
          
          // Close dropdown and remove dropdown-open class
          document.querySelectorAll('.quick-reply-dropdown').forEach(d => {
            d.classList.remove('active');
          });
          document.querySelectorAll('.quick-reply-btn').forEach(b => {
            b.classList.remove('dropdown-open');
          });
        });
      });
    }

    // Insert template into text box
    function insertTemplate(categoryId, templateId) {
      const category = cannedResponsesData.categories.find(c => c.id === categoryId);
      if (!category) return;
      
      const template = category.templates.find(t => t.id === templateId);
      if (!template) return;
      
      const input = document.getElementById('response-input');
      input.value = template.text;
      input.focus();
      
      // Track usage
      trackTemplateUsage(templateId);
    }

    // Track template usage
    function trackTemplateUsage(templateId) {
      let stats = JSON.parse(localStorage.getItem('templateUsageStats') || '{}');
      if (!stats[templateId]) {
        stats[templateId] = { count: 0, lastUsed: null };
      }
      stats[templateId].count++;
      stats[templateId].lastUsed = new Date().toISOString();
      localStorage.setItem('templateUsageStats', JSON.stringify(stats));
      console.log('üìä Template used:', templateId, 'Total uses:', stats[templateId].count);
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', () => {
      document.querySelectorAll('.quick-reply-dropdown').forEach(d => {
        d.classList.remove('active');
      });
      document.querySelectorAll('.quick-reply-btn').forEach(b => {
        b.classList.remove('dropdown-open');
      });
    });

    function startConversationPolling() {
      // Clear any existing polling
      if (conversationPollingInterval) {
        clearInterval(conversationPollingInterval);
      }
      
      // Do an immediate refresh
      setTimeout(refreshConversation, 100);
      
      // Then poll every 2 seconds while modal is open
      conversationPollingInterval = setInterval(() => {
        if (currentSessionId && document.getElementById('conversation-modal').classList.contains('active')) {
          refreshConversation();
        }
      }, 2000);
    }

    function stopConversationPolling() {
      if (conversationPollingInterval) {
        clearInterval(conversationPollingInterval);
        conversationPollingInterval = null;
      }
    }

    async function refreshConversation() {
      if (!currentSessionId) return;
      
      try {
        const response = await fetch(`/api/conversation/${currentSessionId}`);
        const data = await response.json();
        
        // Check for user typing status
        checkUserTypingStatus();
        
        // Check if countdown was cancelled (user sent a message)
        if (endSessionTimeout && !data.countdown) {
          console.log('‚èπÔ∏è Countdown cancelled by user message');
          clearInterval(endSessionTimeout);
          endSessionTimeout = null;
          
          // Reset warn button
          const warnBtn = document.querySelector('.warn-btn');
          if (warnBtn) {
            warnBtn.textContent = 'Warn Before Ending';
            warnBtn.disabled = false;
          }
        }
        
        // Check if there are new messages, status changed, or feedback changed
        const hasNewMessages = !currentConversation || 
                               data.messages.length !== currentConversation.messages.length ||
                               data.status !== currentConversation.status;
        
        const oldThumbsUp = currentConversation?.feedback?.thumbsUp || 0;
        const oldThumbsDown = currentConversation?.feedback?.thumbsDown || 0;
        const newThumbsUp = data.feedback?.thumbsUp || 0;
        const newThumbsDown = data.feedback?.thumbsDown || 0;
        
        const hasFeedbackChanged = oldThumbsUp !== newThumbsUp || oldThumbsDown !== newThumbsDown;
        
        console.log('Refresh check:', {
          messages: `${currentConversation?.messages?.length || 0} ‚Üí ${data.messages?.length || 0}`,
          status: `${currentConversation?.status} ‚Üí ${data.status}`,
          feedback: `${oldThumbsUp}üëç ${oldThumbsDown}üëé ‚Üí ${newThumbsUp}üëç ${newThumbsDown}üëé`,
          hasNewMessages,
          hasFeedbackChanged
        });
        
        if (hasNewMessages) {
          console.log('‚úÖ Updating conversation view (messages/status changed)');
          const messagesEl = document.getElementById('modal-messages');
          
          currentConversation = data;
          renderConversationModal(data);
          
          // Always scroll to bottom on refresh
          messagesEl.scrollTop = messagesEl.scrollHeight;
        } else if (hasFeedbackChanged) {
          console.log('‚úÖ Updating sentiment indicator (feedback changed)');
          currentConversation = data;
          updateSentimentIndicator(data);
        } else {
          // Still update currentConversation to keep data fresh
          currentConversation = data;
        }
      } catch (error) {
        console.error('Error refreshing conversation:', error);
      }
    }

    function renderConversationModal(conversation) {
      const titleEl = document.getElementById('modal-title');
      const messagesEl = document.getElementById('modal-messages');
      
      const statusText = conversation.status === 'human' ? 'üü° Waiting' : 
                        conversation.status === 'responded' ? '‚úÖ Responded' : 
                        conversation.status === 'viewed' ? 'üëÅÔ∏è Viewed' : 
                        conversation.status === 'closed' ? 'üîí Closed' : 'ü§ñ Bot';
      
      // Add avatar to modal title
      const color = getColorForSession(conversation.sessionId);
      const initials = getInitials(conversation.sessionId);
      const avatarUrl = generateAvatar(conversation.sessionId);
      
      titleEl.innerHTML = `
        <div style="display: flex; align-items: center; gap: 12px;">
          <div class="user-avatar" style="background: ${color}; position: relative; overflow: hidden;">
            <img src="${avatarUrl}" alt="User" style="width: 100%; height: 100%; object-fit: cover; position: relative; z-index: 1;" 
                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
            <span style="position: absolute; inset: 0; display: none; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 16px; z-index: 0;">${initials}</span>
          </div>
          <div>
            <div style="font-size: 16px; font-weight: 600;">Session: ${conversation.sessionId.substring(0, 30)}...</div>
            <div style="font-size: 14px; color: #666; margin-top: 2px;">${statusText}</div>
          </div>
        </div>
      `;
      
      // Calculate and display sentiment based on feedback
      updateSentimentIndicator(conversation);
      
      // Disable input and hide quick replies if conversation is closed
      const responseInput = document.getElementById('response-input');
      const sendBtn = document.querySelector('.send-btn');
      const warnBtn = document.querySelector('.warn-btn');
      const endBtn = document.querySelector('.end-session-btn');
      const quickReplies = document.querySelector('.quick-replies');
      
      if (conversation.status === 'closed') {
        responseInput.disabled = true;
        responseInput.placeholder = 'This conversation has been closed';
        sendBtn.disabled = true;
        warnBtn.disabled = true;
        endBtn.disabled = true;
        quickReplies.style.display = 'none';
      } else {
        responseInput.disabled = false;
        responseInput.placeholder = 'Type your response...';
        sendBtn.disabled = false;
        warnBtn.disabled = false;
        endBtn.disabled = false;
        quickReplies.style.display = 'block';
      }
      
      if (!conversation || !conversation.messages || conversation.messages.length === 0) {
        messagesEl.innerHTML = '<div class="empty-state"><p>No messages yet</p></div>';
        return;
      }

      messagesEl.innerHTML = conversation.messages.map(msg => `
        <div class="message ${msg.role || 'unknown'}">
          <div class="message-role">${msg.role || 'unknown'}</div>
          <div class="message-content">${escapeHtml(msg.content || '')}</div>
          <div class="message-time">${msg.timestamp ? new Date(msg.timestamp).toLocaleString() : 'Unknown time'}</div>
        </div>
      `).join('');
      
      // Force scroll to bottom immediately
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }
    
    function updateSentimentIndicator(conversation) {
      const indicator = document.getElementById('sentiment-indicator');
      
      // Count thumbs up and down from feedback
      let thumbsUp = 0;
      let thumbsDown = 0;
      
      if (conversation.feedback) {
        thumbsUp = conversation.feedback.thumbsUp || 0;
        thumbsDown = conversation.feedback.thumbsDown || 0;
      }
      
      const total = thumbsUp + thumbsDown;
      
      // Don't show if no feedback yet
      if (total === 0) {
        indicator.style.display = 'none';
        return;
      }
      
      // Calculate sentiment
      const positiveRatio = thumbsUp / total;
      let emoji, text, bgColor, textColor;
      
      if (positiveRatio >= 0.8) {
        emoji = 'üòä';
        text = 'Very Happy';
        bgColor = '#d1fae5';
        textColor = '#065f46';
      } else if (positiveRatio >= 0.6) {
        emoji = 'üôÇ';
        text = 'Happy';
        bgColor = '#dbeafe';
        textColor = '#1e40af';
      } else if (positiveRatio >= 0.4) {
        emoji = 'üòê';
        text = 'Neutral';
        bgColor = '#fef3c7';
        textColor = '#92400e';
      } else if (positiveRatio >= 0.2) {
        emoji = 'üòï';
        text = 'Unhappy';
        bgColor = '#fed7aa';
        textColor = '#9a3412';
      } else {
        emoji = 'üòû';
        text = 'Very Unhappy';
        bgColor = '#fecaca';
        textColor = '#991b1b';
      }
      
      indicator.innerHTML = `${emoji} ${text} <span style="opacity: 0.7; font-size: 12px;">(${thumbsUp}üëç ${thumbsDown}üëé)</span>`;
      indicator.style.backgroundColor = bgColor;
      indicator.style.color = textColor;
      indicator.style.display = 'inline-block';
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function closeModal() {
      document.getElementById('conversation-modal').classList.remove('active');
      stopConversationPolling();
      
      // Clear any pending countdown
      if (endSessionTimeout) {
        clearInterval(endSessionTimeout);
        endSessionTimeout = null;
        
        // Reset warn button
        const warnBtn = document.querySelector('.warn-btn');
        if (warnBtn) {
          warnBtn.textContent = 'Warn Before Ending';
          warnBtn.disabled = false;
        }
      }
      
      currentSessionId = null;
      currentConversation = null;
      document.getElementById('response-input').value = '';
      
      // Stop sending typing indicator
      stopLibrarianTyping();
    }

    // Typing indicator for librarian
    let librarianTypingTimeout = null;
    let isLibrarianTyping = false;

    // Send librarian typing status
    async function sendLibrarianTypingStatus(isTyping) {
      if (!currentSessionId) return;
      
      try {
        await fetch(`/api/typing/${currentSessionId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ isTyping, role: 'librarian' })
        });
      } catch (error) {
        console.error('Error sending typing status:', error);
      }
    }

    // Stop librarian typing
    function stopLibrarianTyping() {
      if (isLibrarianTyping) {
        isLibrarianTyping = false;
        sendLibrarianTypingStatus(false);
      }
      if (librarianTypingTimeout) {
        clearTimeout(librarianTypingTimeout);
        librarianTypingTimeout = null;
      }
    }

    // Add input event listener for typing indicator
    document.addEventListener('DOMContentLoaded', () => {
      const responseInput = document.getElementById('response-input');
      
      responseInput.addEventListener('input', () => {
        if (!currentSessionId) return;
        
        const hasText = responseInput.value.trim().length > 0;
        
        if (hasText && !isLibrarianTyping) {
          isLibrarianTyping = true;
          sendLibrarianTypingStatus(true);
        }
        
        // Clear existing timeout
        if (librarianTypingTimeout) {
          clearTimeout(librarianTypingTimeout);
        }
        
        // Set new timeout to stop typing indicator
        librarianTypingTimeout = setTimeout(() => {
          stopLibrarianTyping();
        }, 3000); // Stop after 3 seconds of no typing
      });
    });

    // Show user typing indicator in modal
    function showUserTypingIndicator() {
      const messagesEl = document.getElementById('modal-messages');
      
      // Remove existing typing indicator if any
      hideUserTypingIndicator();
      
      const typingDiv = document.createElement('div');
      typingDiv.className = 'message user typing-indicator-msg';
      typingDiv.id = 'user-typing-indicator';
      typingDiv.innerHTML = `
        <div class="typing-dots">
          <span class="typing-label">User is typing</span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </div>
      `;
      messagesEl.appendChild(typingDiv);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // Hide user typing indicator
    function hideUserTypingIndicator() {
      const indicator = document.getElementById('user-typing-indicator');
      if (indicator) indicator.remove();
    }

    // Check for user typing status during conversation refresh
    async function checkUserTypingStatus() {
      if (!currentSessionId) return;
      
      try {
        const response = await fetch(`/api/typing/${currentSessionId}`);
        const data = await response.json();
        
        if (data.user) {
          showUserTypingIndicator();
        } else {
          hideUserTypingIndicator();
        }
      } catch (error) {
        console.error('Error checking typing status:', error);
      }
    }

    async function sendResponse() {
      const input = document.getElementById('response-input');
      const message = input.value.trim();
      
      if (!message || !currentSessionId) {
        return;
      }

      // Stop typing indicator when sending
      stopLibrarianTyping();

      try {
        const response = await fetch('/api/librarian/respond', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: currentSessionId,
            message: message
          })
        });

        // Handle rate limiting
        if (response.status === 429) {
          alert('Too many requests. Please wait a moment and try again.');
          return;
        }

        // Check if response is JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          throw new Error('Server returned non-JSON response');
        }

        const data = await response.json();
        
        if (data.success) {
          input.value = '';
          // Immediately refresh to show the sent message
          refreshConversation();
        } else {
          alert('Error sending message: ' + data.error);
        }
      } catch (error) {
        alert('Error sending message: ' + error.message);
      }
    }

    async function sendWarning() {
      if (!currentSessionId) return;
      
      // Prevent double-clicking
      const warnBtn = document.querySelector('.warn-btn');
      if (warnBtn.disabled) return;

      const warningMessage = "Thank you for your question! I've provided the information you need. If your inquiry has been resolved, I'll be ending this session in 10 seconds. Feel free to ask any follow-up questions now, or you can always start a new chat with the AI assistant or request a librarian again if you need more help later.";

      try {
        const response = await fetch('/api/librarian/respond', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: currentSessionId,
            message: warningMessage
          })
        });

        // Handle rate limiting
        if (response.status === 429) {
          alert('Too many requests. Please wait a moment and try again.');
          return;
        }

        // Check if response is JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          throw new Error('Server returned non-JSON response');
        }

        const data = await response.json();
        
        if (data.success) {
          // Immediately refresh to show the sent message
          refreshConversation();
          
          // Set initial countdown on server
          await fetch('/api/librarian/set-countdown', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              sessionId: currentSessionId,
              countdown: 10
            })
          });
          
          // Start 10-second countdown
          let countdown = 10;
          const warnBtn = document.querySelector('.warn-btn');
          const originalText = warnBtn.textContent;
          warnBtn.disabled = true;
          warnBtn.textContent = `Ending in ${countdown}s...`;
          
          let countdownCancelled = false; // Flag to track if cancelled
          
          const countdownInterval = setInterval(async () => {
            // Check if countdown was cancelled by user message
            try {
              const checkResponse = await fetch(`/api/conversation/${currentSessionId}`);
              const checkData = await checkResponse.json();
              
              if (!checkData.countdown || checkData.countdown <= 0) {
                // User sent a message, countdown was cancelled
                console.log('‚èπÔ∏è Countdown cancelled - user sent message');
                countdownCancelled = true;
                clearInterval(countdownInterval);
                endSessionTimeout = null;
                warnBtn.textContent = originalText;
                warnBtn.disabled = false;
                
                // Show notification to librarian
                alert('‚èπÔ∏è Countdown cancelled - User sent a message. Please continue assisting them.');
                
                // Refresh to show new messages
                refreshConversation();
                return;
              }
            } catch (error) {
              console.error('Error checking countdown:', error);
            }
            
            countdown--;
            warnBtn.textContent = `Ending in ${countdown}s...`;
            
            // Update countdown status on server
            if (countdown > 0) {
              try {
                await fetch('/api/librarian/set-countdown', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    sessionId: currentSessionId,
                    countdown: countdown
                  })
                });
              } catch (error) {
                console.error('Error updating countdown:', error);
              }
            }
            
            if (countdown <= 0 && !countdownCancelled) {
              // Double-check one more time before closing
              try {
                const finalCheckResponse = await fetch(`/api/conversation/${currentSessionId}`);
                const finalCheckData = await finalCheckResponse.json();
                
                if (!finalCheckData.countdown || finalCheckData.countdown <= 0) {
                  // User sent a message at the last second!
                  console.log('‚èπÔ∏è Countdown cancelled at last second - user sent message');
                  clearInterval(countdownInterval);
                  endSessionTimeout = null;
                  warnBtn.textContent = originalText;
                  warnBtn.disabled = false;
                  
                  alert('‚èπÔ∏è Countdown cancelled - User sent a message. Please continue assisting them.');
                  refreshConversation();
                  return;
                }
              } catch (error) {
                console.error('Error in final countdown check:', error);
              }
              
              clearInterval(countdownInterval);
              endSessionTimeout = null;
              warnBtn.textContent = originalText;
              warnBtn.disabled = false;
              
              // Automatically end the session
              endSessionAutomatically();
            }
          }, 1000);
          
          // Store the interval so it can be cancelled if needed
          endSessionTimeout = countdownInterval;
        } else {
          alert('Error sending warning: ' + data.error);
        }
      } catch (error) {
        alert('Error sending warning: ' + error.message);
      }
    }

    async function endSessionAutomatically() {
      if (!currentSessionId) return;

      try {
        const response = await fetch('/api/librarian/end-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId: currentSessionId })
        });

        const data = await response.json();
        
        if (data.success) {
          closeModal();
          loadNotifications(); // Refresh the list
        } else {
          console.error('Error ending session:', data.error);
        }
      } catch (error) {
        console.error('Error ending session:', error.message);
      }
    }

    async function endSession() {
      if (!currentSessionId) return;
      
      if (!confirm('End this session? The user will be returned to the AI assistant.')) {
        return;
      }

      try {
        const response = await fetch('/api/librarian/end-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId: currentSessionId })
        });

        const data = await response.json();
        
        if (data.success) {
          alert('Session ended. User has been returned to the AI assistant.');
          closeModal();
          loadNotifications(); // Refresh the list
        } else {
          alert('Error ending session: ' + data.error);
        }
      } catch (error) {
        alert('Error ending session: ' + error.message);
      }
    }

    // Allow Enter to send (Shift+Enter for new line)
    document.addEventListener('DOMContentLoaded', () => {
      const input = document.getElementById('response-input');
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendResponse();
        }
      });
    });

    // Auto-refresh every 2 seconds
    setInterval(loadNotifications, 2000);
    
    // Initial load
    loadNotifications();
    loadCannedResponses();
  </script>
</body>
</html>
