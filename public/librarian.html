<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Librarian Dashboard</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #f5f7fa;
      padding: 20px;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 28px;
      margin-bottom: 8px;
    }

    .header p {
      opacity: 0.9;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .stat-card h3 {
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
    }

    .stat-card .number {
      font-size: 32px;
      font-weight: 600;
      color: #667eea;
    }

    .conversations {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .conversations-header {
      padding: 20px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .conversations-header h2 {
      font-size: 20px;
    }

    .search-filter-bar {
      padding: 20px;
      border-bottom: 1px solid #e0e0e0;
      background: #f8f9fa;
    }

    .search-box {
      margin-bottom: 12px;
    }

    .search-box input {
      width: 100%;
      padding: 10px 16px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.2s;
    }

    .search-box input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .filter-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .filter-controls select {
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14px;
      background: white;
      cursor: pointer;
      transition: border-color 0.2s;
    }

    .filter-controls select:focus {
      outline: none;
      border-color: #667eea;
    }

    .clear-filters-btn {
      padding: 8px 16px;
      background: #e5e7eb;
      color: #374151;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }

    .clear-filters-btn:hover {
      background: #d1d5db;
    }

    .filter-badge {
      display: inline-block;
      padding: 2px 8px;
      background: #667eea;
      color: white;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
    }

    .no-results {
      padding: 60px 20px;
      text-align: center;
      color: #999;
    }

    .no-results svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      opacity: 0.3;
    }

    .highlight {
      background: #fef3c7;
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: 600;
    }

    .refresh-btn {
      padding: 8px 16px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    .refresh-btn:hover {
      background: #5568d3;
    }

    .conversation-list {
      max-height: 600px;
      overflow-y: auto;
    }

    .conversation-item {
      padding: 20px;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
      transition: background 0.2s;
    }

    .conversation-item:hover {
      background: #f8f9fa;
    }

    .conversation-item.active {
      background: #f0f4ff !important;
      border-left: 4px solid #667eea !important;
    }

    .conversation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .session-id {
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }

    .status-badge {
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
    }

    .status-badge.human {
      background: #fef3c7;
      color: #92400e;
    }

    .status-badge.bot {
      background: #e9d5ff;
      color: #6b21a8;
    }

    .status-badge.viewed {
      background: #dbeafe;
      color: #1e40af;
    }

    .status-badge.responded {
      background: #dcfce7;
      color: #166534;
    }

    .status-badge.closed {
      background: #f3f4f6;
      color: #6b7280;
    }

    .conversation-preview {
      color: #666;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .conversation-time {
      color: #999;
      font-size: 12px;
    }

    .empty-state {
      padding: 60px 20px;
      text-align: center;
      color: #999;
    }

    .empty-state svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      opacity: 0.3;
    }

    /* Notification Alert */
    .notification-alert {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #fef3c7;
      border: 2px solid #f59e0b;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      z-index: 2000;
      animation: slideIn 0.3s ease-out, pulse 2s infinite;
      max-width: 400px;
    }

    #notification-bot.notification-alert {
      background: #dbeafe !important;
      border: 2px solid #3b82f6 !important;
      animation: slideIn 0.3s ease-out !important;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 10px 40px rgba(245, 158, 11, 0.3);
      }
      50% {
        box-shadow: 0 10px 40px rgba(245, 158, 11, 0.6);
      }
    }

    .notification-content {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .notification-icon {
      font-size: 32px;
      animation: ring 1s infinite;
    }

    @keyframes ring {
      0%, 100% { transform: rotate(0deg); }
      10%, 30% { transform: rotate(-10deg); }
      20%, 40% { transform: rotate(10deg); }
    }

    .notification-content strong {
      color: #92400e;
      font-size: 16px;
      display: block;
      margin-bottom: 4px;
    }

    .notification-content p {
      color: #78350f;
      font-size: 14px;
      margin: 0;
    }

    .dismiss-btn {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #92400e;
      padding: 4px;
      margin-left: auto;
    }

    .dismiss-btn:hover {
      color: #78350f;
    }

    /* User Avatar */
    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 16px;
      color: white;
      flex-shrink: 0;
    }

    .conversation-item.waiting {
      background: #fef3c7 !important;
      border-left: 4px solid #f59e0b !important;
    }

    .conversation-item.waiting:hover {
      background: #fde68a !important;
    }

    .unread-indicator {
      width: 12px;
      height: 12px;
      background: #ef4444;
      border-radius: 50%;
      border: 2px solid white;
      flex-shrink: 0;
    }

    /* Conversation Detail Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
      padding: 20px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h3 {
      font-size: 18px;
      color: #333;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #999;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
    }

    .close-btn:hover {
      background: #f0f0f0;
      color: #333;
    }

    .modal-messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      background: #f8f9fa;
    }

    .message {
      margin-bottom: 16px;
      padding: 12px 16px;
      border-radius: 8px;
      max-width: 80%;
    }

    .message.user {
      background: #e5e7eb;
      margin-right: auto;
    }

    .message.bot {
      background: #dbeafe;
      margin-right: auto;
    }

    .message.librarian {
      background: #dcfce7;
      margin-left: auto;
    }

    .message-role {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 4px;
      opacity: 0.7;
    }

    .message-content {
      font-size: 14px;
      line-height: 1.5;
    }

    .message-time {
      font-size: 11px;
      opacity: 0.6;
      margin-top: 4px;
    }

    .modal-input {
      padding: 20px;
      border-top: 1px solid #e0e0e0;
      display: flex;
      gap: 12px;
    }

    .modal-input textarea {
      flex: 1;
      padding: 12px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      resize: none;
      min-height: 60px;
    }

    .modal-input textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    .send-btn {
      padding: 12px 24px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      align-self: flex-end;
    }

    .send-btn:hover {
      background: #5568d3;
    }

    .send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .end-session-btn {
      padding: 12px 24px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    .end-session-btn:hover {
      background: #dc2626;
    }

    .end-session-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .warn-btn {
      padding: 12px 24px;
      background: #f59e0b;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    .warn-btn:hover {
      background: #d97706;
    }

    .warn-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Quick Replies */
    .quick-replies {
      padding: 12px 20px;
      border-top: 1px solid #e0e0e0;
      background: #f8f9fa;
    }

    .quick-replies-label {
      font-size: 12px;
      font-weight: 600;
      color: #666;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .quick-reply-buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .quick-reply-btn {
      padding: 10px 12px;
      background: #e0f2fe;
      border: 1px solid #bae6fd;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: #0369a1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.2s;
      position: relative;
      z-index: 1;
    }

    .quick-reply-btn.dropdown-open {
      z-index: 2001;
    }

    .quick-reply-btn:hover {
      background: #bae6fd;
      border-color: #7dd3fc;
      transform: translateY(-1px);
    }

    .quick-reply-btn:active {
      transform: translateY(0);
    }

    .quick-reply-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      min-width: 250px;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 2000;
      max-height: 300px;
      overflow-y: auto;
      display: none;
    }

    .quick-reply-dropdown.active {
      display: block;
      animation: slideDown 0.2s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .quick-reply-option {
      padding: 12px 16px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      transition: background 0.2s;
    }

    .quick-reply-option:last-child {
      border-bottom: none;
    }

    .quick-reply-option:hover {
      background: #f8f9fa;
    }

    .quick-reply-option-name {
      font-size: 14px;
      font-weight: 500;
      color: #333;
      margin-bottom: 4px;
    }

    .quick-reply-option-preview {
      font-size: 12px;
      color: #666;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Mobile Responsiveness */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .header {
        padding: 20px;
      }

      .header h1 {
        font-size: 22px;
      }

      .stats {
        grid-template-columns: 1fr;
      }

      .quick-reply-buttons {
        grid-template-columns: repeat(2, 1fr);
      }

      .modal-content {
        width: 95%;
        max-height: 95vh;
      }

      .modal-input {
        flex-direction: column;
      }

      .modal-input textarea {
        min-height: 80px;
      }

      .conversation-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }

      .notification-alert {
        right: 10px;
        left: 10px;
        max-width: none;
      }

      .filter-controls {
        flex-direction: column;
      }

      .filter-controls select,
      .clear-filters-btn {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üìö Librarian Dashboard</h1>
    <p>Monitor and respond to chat conversations</p>
    <p style="font-size: 12px; opacity: 0.8; margin-top: 8px;">üîÑ Auto-refreshes every 2 seconds</p>
  </div>

  <!-- Notification Alerts -->
  <div id="notification-librarian" class="notification-alert" style="display: none; top: 20px;">
    <div class="notification-content">
      <span class="notification-icon">üîî</span>
      <div>
        <strong>User Requesting Librarian!</strong>
        <p id="notification-librarian-text">A user wants to talk with a librarian</p>
      </div>
      <button onclick="dismissNotification('librarian')" class="dismiss-btn">‚úï</button>
    </div>
  </div>

  <div id="notification-bot" class="notification-alert notification-bot" style="display: none; top: 100px; background: #dbeafe !important; border: 2px solid #3b82f6 !important;">
    <div class="notification-content">
      <span class="notification-icon">üí¨</span>
      <div>
        <strong>Active Bot Conversations</strong>
        <p id="notification-bot-text">Users chatting with the bot</p>
      </div>
      <button onclick="dismissNotification('bot')" class="dismiss-btn">‚úï</button>
    </div>
  </div>

  <div class="stats">
    <div class="stat-card">
      <h3>Active Conversations</h3>
      <div class="number" id="active-count">0</div>
    </div>
    <div class="stat-card">
      <h3>Pending Requests</h3>
      <div class="number" id="pending-count">0</div>
    </div>
    <div class="stat-card">
      <h3>Total Messages</h3>
      <div class="number" id="message-count">0</div>
    </div>
  </div>

  <div class="conversations">
    <div class="conversations-header">
      <h2>Conversations</h2>
      <button class="refresh-btn" onclick="loadNotifications()">üîÑ Refresh</button>
    </div>
    
    <!-- Search and Filter Controls -->
    <div class="search-filter-bar">
      <div class="search-box">
        <input type="text" id="search-input" placeholder="üîç Search conversations..." oninput="debouncedFilterConversations()">
      </div>
      <div class="filter-controls">
        <select id="status-filter" onchange="filterConversations()">
          <option value="all">All Status</option>
          <option value="bot">Bot</option>
          <option value="human">Waiting</option>
          <option value="responded">Responded</option>
          <option value="viewed">Viewed</option>
          <option value="closed">Closed</option>
        </select>
        <select id="sort-by" onchange="filterConversations()">
          <option value="newest">Newest First</option>
          <option value="oldest">Oldest First</option>
          <option value="most-messages">Most Messages</option>
          <option value="least-messages">Least Messages</option>
        </select>
        <button class="clear-filters-btn" onclick="clearFilters()">Clear Filters</button>
      </div>
    </div>
    
    <div class="conversation-list" id="conversation-list">
      <div class="empty-state">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
        </svg>
        <p>No active conversations</p>
      </div>
    </div>
  </div>

  <!-- Conversation Detail Modal -->
  <div class="modal" id="conversation-modal">
    <div class="modal-content">
      <div class="modal-header">
        <div style="display: flex; align-items: center; gap: 12px;">
          <h3 id="modal-title">Conversation</h3>
          <div id="sentiment-indicator" style="display: none; padding: 6px 12px; border-radius: 20px; font-size: 14px; font-weight: 500;">
            <!-- Sentiment will be shown here -->
          </div>
        </div>
        <button class="close-btn" onclick="closeModal()">√ó</button>
      </div>
      <div class="modal-messages" id="modal-messages">
        <!-- Messages will be loaded here -->
      </div>
      <div class="quick-replies">
        <div class="quick-replies-label">üí¨ Quick Replies:</div>
        <div class="quick-reply-buttons" id="quick-reply-buttons">
          <!-- Quick reply buttons will be loaded here -->
        </div>
      </div>
      <div class="modal-input">
        <textarea id="response-input" placeholder="Type your response..."></textarea>
        <div style="display: flex; flex-direction: column; gap: 8px;">
          <button class="send-btn" onclick="sendResponse()">Send</button>
          <button class="warn-btn" onclick="sendWarning()">Warn Before Ending</button>
          <button class="end-session-btn" onclick="endSession()">End Session</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let currentSessionId = null;
    let currentConversation = null;
    let lastNotificationCount = 0;
    let lastActiveCount = 0;
    let notificationSound = null;
    let librarianNotificationTimeout = null;
    let botNotificationTimeout = null;
    let viewedConversations = new Set(JSON.parse(localStorage.getItem('viewedConversations') || '[]')); // Track which conversations have been viewed
    let lastConversationsHash = ''; // Track if conversations changed

    // Save viewed conversations to localStorage whenever it changes
    function saveViewedConversations() {
      localStorage.setItem('viewedConversations', JSON.stringify([...viewedConversations]));
    }

    // Create notification sound
    function initNotificationSound() {
      // Create a simple beep sound using Web Audio API
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      notificationSound = () => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
      };
    }

    // Initialize on first user interaction
    document.addEventListener('click', () => {
      if (!notificationSound) initNotificationSound();
    }, { once: true });

    function getColorForSession(sessionId) {
      // Generate consistent color based on session ID
      const colors = [
        '#667eea', '#764ba2', '#f093fb', '#4facfe',
        '#43e97b', '#fa709a', '#fee140', '#30cfd0',
        '#a8edea', '#fed6e3', '#fbc2eb', '#a6c1ee'
      ];
      let hash = 0;
      for (let i = 0; i < sessionId.length; i++) {
        hash = sessionId.charCodeAt(i) + ((hash << 5) - hash);
      }
      return colors[Math.abs(hash) % colors.length];
    }

    function getInitials(sessionId) {
      // Generate initials from session ID
      const parts = sessionId.split('-');
      if (parts.length >= 2) {
        return (parts[0][0] + parts[1][0]).toUpperCase();
      }
      return sessionId.substring(0, 2).toUpperCase();
    }
    
    function generateAvatar(sessionId) {
      // Use DiceBear API for consistent avatars
      const style = 'avataaars';
      return `https://api.dicebear.com/7.x/${style}/svg?seed=${sessionId}&backgroundColor=b6e3f4,c0aede,d1d4f9`;
    }

    function showNotification(count, type = 'librarian', playSound = true) {
      if (type === 'librarian') {
        // High priority - user requesting librarian
        const alert = document.getElementById('notification-librarian');
        const text = document.getElementById('notification-librarian-text');
        
        text.textContent = count === 1 
          ? '1 user is requesting to talk with a librarian' 
          : `${count} users are requesting to talk with a librarian`;
        
        alert.style.display = 'block';
        
        // Play sound for librarian requests (only if requested)
        if (playSound && notificationSound) {
          try {
            notificationSound();
          } catch (e) {
            console.log('Could not play sound:', e);
          }
        }
        
        // Clear previous timeout and set new one
        if (librarianNotificationTimeout) {
          clearTimeout(librarianNotificationTimeout);
        }
        // Don't auto-dismiss - let updateStats handle it based on count
        librarianNotificationTimeout = null;
      } else {
        // Low priority - bot conversations
        const alert = document.getElementById('notification-bot');
        const text = document.getElementById('notification-bot-text');
        
        text.textContent = count === 1 
          ? '1 user chatting with the bot' 
          : `${count} users chatting with the bot`;
        
        alert.style.display = 'block';
        
        // Don't auto-dismiss - let updateStats handle it based on count
        // Clear any existing timeout
        if (botNotificationTimeout) {
          clearTimeout(botNotificationTimeout);
          botNotificationTimeout = null;
        }
      }
    }

    function dismissNotification(type) {
      if (type === 'librarian') {
        const alert = document.getElementById('notification-librarian');
        alert.style.display = 'none';
        if (librarianNotificationTimeout) {
          clearTimeout(librarianNotificationTimeout);
        }
      } else {
        const alert = document.getElementById('notification-bot');
        alert.style.display = 'none';
        if (botNotificationTimeout) {
          clearTimeout(botNotificationTimeout);
        }
      }
    }

    async function loadNotifications() {
      try {
        const response = await fetch('/api/librarian/notifications');
        const data = await response.json();
        
        // Create hash of conversations to detect changes
        const conversationsHash = JSON.stringify(data.activeConversations.map(c => ({
          id: c.sessionId,
          status: c.status,
          count: c.messageCount
        })));
        
        // Only update if something changed
        if (conversationsHash !== lastConversationsHash) {
          updateStats(data);
          
          // Store all conversations for filtering
          allConversations = data.activeConversations;
          
          // Apply current filters
          filterConversations();
          
          lastConversationsHash = conversationsHash;
        }
      } catch (error) {
        console.error('Error loading notifications:', error);
      }
    }

    function updateStats(data) {
      // Cache conversations for immediate updates
      cachedConversations = data.activeConversations;
      
      // Clean up viewed conversations - remove sessions that no longer exist
      const activeSessionIds = new Set(data.activeConversations.map(c => c.sessionId));
      const viewedArray = [...viewedConversations];
      let cleaned = false;
      viewedArray.forEach(sessionId => {
        if (!activeSessionIds.has(sessionId)) {
          viewedConversations.delete(sessionId);
          cleaned = true;
        }
      });
      if (cleaned) {
        saveViewedConversations();
      }
      
      const unreadLibrarian = data.activeConversations.filter(c => 
        c.status === 'human'
      ).length;
      
      const unreadBot = data.activeConversations.filter(c => 
        c.status === 'bot' && !viewedConversations.has(c.sessionId)
      ).length;
      
      const totalActive = data.activeConversations.length;
      const totalPending = data.activeConversations.filter(c => c.status === 'human').length;
      const totalMessages = data.activeConversations.reduce((sum, c) => sum + c.messageCount, 0);
      
      document.getElementById('active-count').textContent = totalActive;
      document.getElementById('pending-count').textContent = totalPending;
      document.getElementById('message-count').textContent = totalMessages;
      
      // Remove 'human' status conversations from viewedConversations (they need attention again)
      data.activeConversations.forEach(c => {
        if (c.status === 'human' && viewedConversations.has(c.sessionId)) {
          viewedConversations.delete(c.sessionId);
          saveViewedConversations();
        }
      });
      
      // Show notification for librarian requests (always show, regardless of viewed status)
      if (unreadLibrarian > 0) {
        // Play sound if count increased
        const shouldPlaySound = unreadLibrarian > lastNotificationCount;
        showNotification(unreadLibrarian, 'librarian', shouldPlaySound);
      } else {
        dismissNotification('librarian');
      }
      lastNotificationCount = unreadLibrarian;
      
      // Show notification for unread bot conversations
      if (unreadBot > 0) {
        showNotification(unreadBot, 'bot', false);
      } else {
        dismissNotification('bot');
      }
      
      lastActiveCount = totalActive;
    }

    // Store original conversations for filtering
    let allConversations = [];
    let filteredConversations = [];
    let filterDebounceTimer = null;

    // Debounced filter function
    function debouncedFilterConversations() {
      if (filterDebounceTimer) {
        clearTimeout(filterDebounceTimer);
      }
      filterDebounceTimer = setTimeout(filterConversations, 300);
    }

    // Filter conversations based on search and filters
    function filterConversations() {
      const searchQuery = document.getElementById('search-input').value.toLowerCase();
      const statusFilter = document.getElementById('status-filter').value;
      const sortBy = document.getElementById('sort-by').value;

      // Start with all conversations
      let filtered = [...allConversations];

      // Apply search filter
      if (searchQuery) {
        filtered = filtered.filter(conv => {
          const sessionMatch = conv.sessionId.toLowerCase().includes(searchQuery);
          const messageMatch = conv.lastMessage && conv.lastMessage.content.toLowerCase().includes(searchQuery);
          return sessionMatch || messageMatch;
        });
      }

      // Apply status filter
      if (statusFilter !== 'all') {
        filtered = filtered.filter(conv => conv.status === statusFilter);
      }

      // Apply sorting
      filtered.sort((a, b) => {
        switch (sortBy) {
          case 'newest':
            return new Date(b.startTime) - new Date(a.startTime);
          case 'oldest':
            return new Date(a.startTime) - new Date(b.startTime);
          case 'most-messages':
            return b.messageCount - a.messageCount;
          case 'least-messages':
            return a.messageCount - b.messageCount;
          default:
            return 0;
        }
      });

      filteredConversations = filtered;
      renderConversations(filtered, searchQuery);
      
      // Update header with filter count
      updateFilterBadge(filtered.length, allConversations.length);
    }

    // Clear all filters
    function clearFilters() {
      document.getElementById('search-input').value = '';
      document.getElementById('status-filter').value = 'all';
      document.getElementById('sort-by').value = 'newest';
      filterConversations();
    }

    // Update filter badge
    function updateFilterBadge(filteredCount, totalCount) {
      const header = document.querySelector('.conversations-header h2');
      const existingBadge = header.querySelector('.filter-badge');
      
      if (existingBadge) {
        existingBadge.remove();
      }
      
      if (filteredCount < totalCount) {
        const badge = document.createElement('span');
        badge.className = 'filter-badge';
        badge.textContent = `${filteredCount} of ${totalCount}`;
        header.appendChild(badge);
      }
    }

    // Highlight search terms
    function highlightText(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${query})`, 'gi');
      return text.replace(regex, '<span class="highlight">$1</span>');
    }

    function renderConversations(conversations, searchQuery = '') {
      const listEl = document.getElementById('conversation-list');
      
      if (conversations.length === 0) {
        // Check if it's because of filters
        const hasFilters = document.getElementById('search-input').value || 
                          document.getElementById('status-filter').value !== 'all';
        
        if (hasFilters) {
          listEl.innerHTML = `
            <div class="no-results">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
              </svg>
              <p>No conversations match your filters</p>
              <button class="clear-filters-btn" onclick="clearFilters()" style="margin-top: 12px;">Clear Filters</button>
            </div>
          `;
        } else {
          listEl.innerHTML = `
            <div class="empty-state">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
              </svg>
              <p>No active conversations</p>
            </div>
          `;
        }
        return;
      }

      listEl.innerHTML = conversations.map(conv => {
        const color = getColorForSession(conv.sessionId);
        const initials = getInitials(conv.sessionId);
        const avatarUrl = generateAvatar(conv.sessionId);
        const isWaiting = conv.status === 'human';
        const isUnread = !viewedConversations.has(conv.sessionId) && conv.status === 'bot';
        
        // Highlight search terms
        const sessionIdDisplay = searchQuery ? 
          highlightText(conv.sessionId.substring(0, 20), searchQuery) : 
          conv.sessionId.substring(0, 20);
        
        const previewText = conv.lastMessage ? conv.lastMessage.content.substring(0, 80) : 'No messages yet';
        const previewDisplay = searchQuery ? 
          highlightText(previewText, searchQuery) : 
          previewText;
        
        return `
        <div class="conversation-item ${isWaiting ? 'waiting' : ''}" 
             data-session="${conv.sessionId}" 
             onclick="viewConversation('${conv.sessionId}')"
             style="${isWaiting ? 'background: #fef3c7 !important; border-left: 4px solid #f59e0b !important;' : ''}">
          <div class="conversation-header">
            <div style="display: flex; align-items: center; gap: 12px;">
              ${isUnread ? '<div class="unread-indicator"></div>' : ''}
              <div class="user-avatar" style="background: ${color}; position: relative; overflow: hidden;">
                <img src="${avatarUrl}" alt="User" style="width: 100%; height: 100%; object-fit: cover; position: relative; z-index: 1;" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                <span style="position: absolute; inset: 0; display: none; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 16px; z-index: 0;">${initials}</span>
              </div>
              <span class="session-id">${sessionIdDisplay}...</span>
            </div>
            <span class="status-badge ${conv.status}">
              ${conv.status === 'human' ? 'üü° Waiting' : conv.status === 'responded' ? '‚úÖ Responded' : conv.status === 'viewed' ? 'üëÅÔ∏è Viewed' : conv.status === 'closed' ? 'üîí Closed' : 'ü§ñ Bot'}
            </span>
          </div>
          <div class="conversation-preview">
            ${previewDisplay}${previewText.length > 80 ? '...' : ''}
          </div>
          <div class="conversation-time">
            ${new Date(conv.startTime).toLocaleString()} ‚Ä¢ ${conv.messageCount} messages
          </div>
        </div>
      `;
      }).join('');
    }

    function viewConversation(sessionId) {
      currentSessionId = sessionId;
      const conv = document.querySelector(`[data-session="${sessionId}"]`);
      
      // Mark this conversation as viewed
      viewedConversations.add(sessionId);
      saveViewedConversations(); // Persist to localStorage
      
      // Update notification counts immediately (no API call needed)
      updateNotificationCountsImmediate();
      
      // Re-render conversations to remove red dot immediately
      if (cachedConversations && cachedConversations.length > 0) {
        renderConversations(cachedConversations);
      }
      
      // Fetch full conversation
      fetch(`/api/conversation/${sessionId}`)
        .then(res => res.json())
        .then(data => {
          currentConversation = data;
          renderConversationModal(data);
          document.getElementById('conversation-modal').classList.add('active');
          
          // Start auto-refresh for this conversation
          startConversationPolling();
        })
        .catch(error => {
          alert('Error loading conversation: ' + error.message);
        });
    }

    let cachedConversations = [];

    function updateNotificationCountsImmediate() {
      // Don't automatically remove 'human' status from viewedConversations
      // Only remove if there are NEW messages since last view
      // This prevents the red dot from reappearing just because status changed
      
      // Use cached data to update counts immediately
      const unreadLibrarian = cachedConversations.filter(c => 
        c.status === 'human'
      ).length;
      
      const unreadBot = cachedConversations.filter(c => 
        c.status === 'bot' && !viewedConversations.has(c.sessionId)
      ).length;
      
      // Update notifications with unread counts
      if (unreadLibrarian > 0) {
        showNotification(unreadLibrarian, 'librarian');
      } else {
        dismissNotification('librarian');
      }
      
      if (unreadBot > 0) {
        showNotification(unreadBot, 'bot');
      } else {
        dismissNotification('bot');
      }
      
      // Re-render conversations to update yellow highlighting
      if (cachedConversations && cachedConversations.length > 0) {
        renderConversations(cachedConversations);
      }
    }

    let conversationPollingInterval = null;
    let endSessionTimeout = null; // Track countdown timer
    let cannedResponsesData = null; // Store canned responses

    // Load canned responses
    async function loadCannedResponses() {
      try {
        const response = await fetch('/api/canned-responses');
        cannedResponsesData = await response.json();
        renderQuickReplyButtons();
      } catch (error) {
        console.error('Error loading canned responses:', error);
      }
    }

    // Render quick reply buttons
    function renderQuickReplyButtons() {
      const container = document.getElementById('quick-reply-buttons');
      if (!cannedResponsesData || !cannedResponsesData.categories) return;
      
      container.innerHTML = cannedResponsesData.categories.map(category => `
        <div class="quick-reply-btn" data-category="${category.id}">
          <span>${category.icon}</span>
          <span>${category.name}</span>
          <div class="quick-reply-dropdown" id="dropdown-${category.id}">
            ${category.templates.map(template => `
              <div class="quick-reply-option" data-template-id="${template.id}" data-category-id="${category.id}">
                <div class="quick-reply-option-name">${template.name}</div>
                <div class="quick-reply-option-preview">${template.text.substring(0, 60)}...</div>
              </div>
            `).join('')}
          </div>
        </div>
      `).join('');
      
      // Add click handlers
      document.querySelectorAll('.quick-reply-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const categoryId = btn.dataset.category;
          const dropdown = document.getElementById(`dropdown-${categoryId}`);
          
          // Close all other dropdowns and remove dropdown-open class
          document.querySelectorAll('.quick-reply-dropdown').forEach(d => {
            if (d !== dropdown) d.classList.remove('active');
          });
          document.querySelectorAll('.quick-reply-btn').forEach(b => {
            if (b !== btn) b.classList.remove('dropdown-open');
          });
          
          // Toggle this dropdown
          dropdown.classList.toggle('active');
          btn.classList.toggle('dropdown-open');
        });
      });
      
      // Add template click handlers
      document.querySelectorAll('.quick-reply-option').forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          const categoryId = option.dataset.categoryId;
          const templateId = option.dataset.templateId;
          insertTemplate(categoryId, templateId);
          
          // Close dropdown and remove dropdown-open class
          document.querySelectorAll('.quick-reply-dropdown').forEach(d => {
            d.classList.remove('active');
          });
          document.querySelectorAll('.quick-reply-btn').forEach(b => {
            b.classList.remove('dropdown-open');
          });
        });
      });
    }

    // Insert template into text box
    function insertTemplate(categoryId, templateId) {
      const category = cannedResponsesData.categories.find(c => c.id === categoryId);
      if (!category) return;
      
      const template = category.templates.find(t => t.id === templateId);
      if (!template) return;
      
      const input = document.getElementById('response-input');
      input.value = template.text;
      input.focus();
      
      // Track usage
      trackTemplateUsage(templateId);
    }

    // Track template usage
    function trackTemplateUsage(templateId) {
      let stats = JSON.parse(localStorage.getItem('templateUsageStats') || '{}');
      if (!stats[templateId]) {
        stats[templateId] = { count: 0, lastUsed: null };
      }
      stats[templateId].count++;
      stats[templateId].lastUsed = new Date().toISOString();
      localStorage.setItem('templateUsageStats', JSON.stringify(stats));
      console.log('üìä Template used:', templateId, 'Total uses:', stats[templateId].count);
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', () => {
      document.querySelectorAll('.quick-reply-dropdown').forEach(d => {
        d.classList.remove('active');
      });
      document.querySelectorAll('.quick-reply-btn').forEach(b => {
        b.classList.remove('dropdown-open');
      });
    });

    function startConversationPolling() {
      // Clear any existing polling
      if (conversationPollingInterval) {
        clearInterval(conversationPollingInterval);
      }
      
      // Do an immediate refresh
      setTimeout(refreshConversation, 100);
      
      // Then poll every 2 seconds while modal is open
      conversationPollingInterval = setInterval(() => {
        if (currentSessionId && document.getElementById('conversation-modal').classList.contains('active')) {
          refreshConversation();
        }
      }, 2000);
    }

    function stopConversationPolling() {
      if (conversationPollingInterval) {
        clearInterval(conversationPollingInterval);
        conversationPollingInterval = null;
      }
    }

    async function refreshConversation() {
      if (!currentSessionId) return;
      
      try {
        const response = await fetch(`/api/conversation/${currentSessionId}`);
        const data = await response.json();
        
        // Check if countdown was cancelled (user sent a message)
        if (endSessionTimeout && !data.countdown) {
          console.log('‚èπÔ∏è Countdown cancelled by user message');
          clearInterval(endSessionTimeout);
          endSessionTimeout = null;
          
          // Reset warn button
          const warnBtn = document.querySelector('.warn-btn');
          if (warnBtn) {
            warnBtn.textContent = 'Warn Before Ending';
            warnBtn.disabled = false;
          }
        }
        
        // Check if there are new messages, status changed, or feedback changed
        const hasNewMessages = !currentConversation || 
                               data.messages.length !== currentConversation.messages.length ||
                               data.status !== currentConversation.status;
        
        const oldThumbsUp = currentConversation?.feedback?.thumbsUp || 0;
        const oldThumbsDown = currentConversation?.feedback?.thumbsDown || 0;
        const newThumbsUp = data.feedback?.thumbsUp || 0;
        const newThumbsDown = data.feedback?.thumbsDown || 0;
        
        const hasFeedbackChanged = oldThumbsUp !== newThumbsUp || oldThumbsDown !== newThumbsDown;
        
        console.log('Refresh check:', {
          messages: `${currentConversation?.messages?.length || 0} ‚Üí ${data.messages?.length || 0}`,
          status: `${currentConversation?.status} ‚Üí ${data.status}`,
          feedback: `${oldThumbsUp}üëç ${oldThumbsDown}üëé ‚Üí ${newThumbsUp}üëç ${newThumbsDown}üëé`,
          hasNewMessages,
          hasFeedbackChanged
        });
        
        if (hasNewMessages) {
          console.log('‚úÖ Updating conversation view (messages/status changed)');
          const messagesEl = document.getElementById('modal-messages');
          
          currentConversation = data;
          renderConversationModal(data);
          
          // Always scroll to bottom on refresh
          messagesEl.scrollTop = messagesEl.scrollHeight;
        } else if (hasFeedbackChanged) {
          console.log('‚úÖ Updating sentiment indicator (feedback changed)');
          currentConversation = data;
          updateSentimentIndicator(data);
        } else {
          // Still update currentConversation to keep data fresh
          currentConversation = data;
        }
      } catch (error) {
        console.error('Error refreshing conversation:', error);
      }
    }

    function renderConversationModal(conversation) {
      const titleEl = document.getElementById('modal-title');
      const messagesEl = document.getElementById('modal-messages');
      
      const statusText = conversation.status === 'human' ? 'üü° Waiting' : 
                        conversation.status === 'responded' ? '‚úÖ Responded' : 
                        conversation.status === 'viewed' ? 'üëÅÔ∏è Viewed' : 
                        conversation.status === 'closed' ? 'üîí Closed' : 'ü§ñ Bot';
      
      // Add avatar to modal title
      const color = getColorForSession(conversation.sessionId);
      const initials = getInitials(conversation.sessionId);
      const avatarUrl = generateAvatar(conversation.sessionId);
      
      titleEl.innerHTML = `
        <div style="display: flex; align-items: center; gap: 12px;">
          <div class="user-avatar" style="background: ${color}; position: relative; overflow: hidden;">
            <img src="${avatarUrl}" alt="User" style="width: 100%; height: 100%; object-fit: cover; position: relative; z-index: 1;" 
                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
            <span style="position: absolute; inset: 0; display: none; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 16px; z-index: 0;">${initials}</span>
          </div>
          <div>
            <div style="font-size: 16px; font-weight: 600;">Session: ${conversation.sessionId.substring(0, 30)}...</div>
            <div style="font-size: 14px; color: #666; margin-top: 2px;">${statusText}</div>
          </div>
        </div>
      `;
      
      // Calculate and display sentiment based on feedback
      updateSentimentIndicator(conversation);
      
      // Disable input and hide quick replies if conversation is closed
      const responseInput = document.getElementById('response-input');
      const sendBtn = document.querySelector('.send-btn');
      const warnBtn = document.querySelector('.warn-btn');
      const endBtn = document.querySelector('.end-session-btn');
      const quickReplies = document.querySelector('.quick-replies');
      
      if (conversation.status === 'closed') {
        responseInput.disabled = true;
        responseInput.placeholder = 'This conversation has been closed';
        sendBtn.disabled = true;
        warnBtn.disabled = true;
        endBtn.disabled = true;
        quickReplies.style.display = 'none';
      } else {
        responseInput.disabled = false;
        responseInput.placeholder = 'Type your response...';
        sendBtn.disabled = false;
        warnBtn.disabled = false;
        endBtn.disabled = false;
        quickReplies.style.display = 'block';
      }
      
      if (!conversation || !conversation.messages || conversation.messages.length === 0) {
        messagesEl.innerHTML = '<div class="empty-state"><p>No messages yet</p></div>';
        return;
      }

      messagesEl.innerHTML = conversation.messages.map(msg => `
        <div class="message ${msg.role || 'unknown'}">
          <div class="message-role">${msg.role || 'unknown'}</div>
          <div class="message-content">${escapeHtml(msg.content || '')}</div>
          <div class="message-time">${msg.timestamp ? new Date(msg.timestamp).toLocaleString() : 'Unknown time'}</div>
        </div>
      `).join('');
      
      // Force scroll to bottom immediately
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }
    
    function updateSentimentIndicator(conversation) {
      const indicator = document.getElementById('sentiment-indicator');
      
      // Count thumbs up and down from feedback
      let thumbsUp = 0;
      let thumbsDown = 0;
      
      if (conversation.feedback) {
        thumbsUp = conversation.feedback.thumbsUp || 0;
        thumbsDown = conversation.feedback.thumbsDown || 0;
      }
      
      const total = thumbsUp + thumbsDown;
      
      // Don't show if no feedback yet
      if (total === 0) {
        indicator.style.display = 'none';
        return;
      }
      
      // Calculate sentiment
      const positiveRatio = thumbsUp / total;
      let emoji, text, bgColor, textColor;
      
      if (positiveRatio >= 0.8) {
        emoji = 'üòä';
        text = 'Very Happy';
        bgColor = '#d1fae5';
        textColor = '#065f46';
      } else if (positiveRatio >= 0.6) {
        emoji = 'üôÇ';
        text = 'Happy';
        bgColor = '#dbeafe';
        textColor = '#1e40af';
      } else if (positiveRatio >= 0.4) {
        emoji = 'üòê';
        text = 'Neutral';
        bgColor = '#fef3c7';
        textColor = '#92400e';
      } else if (positiveRatio >= 0.2) {
        emoji = 'üòï';
        text = 'Unhappy';
        bgColor = '#fed7aa';
        textColor = '#9a3412';
      } else {
        emoji = 'üòû';
        text = 'Very Unhappy';
        bgColor = '#fecaca';
        textColor = '#991b1b';
      }
      
      indicator.innerHTML = `${emoji} ${text} <span style="opacity: 0.7; font-size: 12px;">(${thumbsUp}üëç ${thumbsDown}üëé)</span>`;
      indicator.style.backgroundColor = bgColor;
      indicator.style.color = textColor;
      indicator.style.display = 'inline-block';
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function closeModal() {
      document.getElementById('conversation-modal').classList.remove('active');
      stopConversationPolling();
      
      // Clear any pending countdown
      if (endSessionTimeout) {
        clearInterval(endSessionTimeout);
        endSessionTimeout = null;
        
        // Reset warn button
        const warnBtn = document.querySelector('.warn-btn');
        if (warnBtn) {
          warnBtn.textContent = 'Warn Before Ending';
          warnBtn.disabled = false;
        }
      }
      
      currentSessionId = null;
      currentConversation = null;
      document.getElementById('response-input').value = '';
    }

    async function sendResponse() {
      const input = document.getElementById('response-input');
      const message = input.value.trim();
      
      if (!message || !currentSessionId) {
        return;
      }

      try {
        const response = await fetch('/api/librarian/respond', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: currentSessionId,
            message: message
          })
        });

        // Handle rate limiting
        if (response.status === 429) {
          alert('Too many requests. Please wait a moment and try again.');
          return;
        }

        // Check if response is JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          throw new Error('Server returned non-JSON response');
        }

        const data = await response.json();
        
        if (data.success) {
          input.value = '';
          // Immediately refresh to show the sent message
          refreshConversation();
        } else {
          alert('Error sending message: ' + data.error);
        }
      } catch (error) {
        alert('Error sending message: ' + error.message);
      }
    }

    async function sendWarning() {
      if (!currentSessionId) return;
      
      // Prevent double-clicking
      const warnBtn = document.querySelector('.warn-btn');
      if (warnBtn.disabled) return;

      const warningMessage = "Thank you for your question! I've provided the information you need. If your inquiry has been resolved, I'll be ending this session in 10 seconds. Feel free to ask any follow-up questions now, or you can always start a new chat with the AI assistant or request a librarian again if you need more help later.";

      try {
        const response = await fetch('/api/librarian/respond', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: currentSessionId,
            message: warningMessage
          })
        });

        // Handle rate limiting
        if (response.status === 429) {
          alert('Too many requests. Please wait a moment and try again.');
          return;
        }

        // Check if response is JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          throw new Error('Server returned non-JSON response');
        }

        const data = await response.json();
        
        if (data.success) {
          // Immediately refresh to show the sent message
          refreshConversation();
          
          // Set initial countdown on server
          await fetch('/api/librarian/set-countdown', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              sessionId: currentSessionId,
              countdown: 10
            })
          });
          
          // Start 10-second countdown
          let countdown = 10;
          const warnBtn = document.querySelector('.warn-btn');
          const originalText = warnBtn.textContent;
          warnBtn.disabled = true;
          warnBtn.textContent = `Ending in ${countdown}s...`;
          
          let countdownCancelled = false; // Flag to track if cancelled
          
          const countdownInterval = setInterval(async () => {
            // Check if countdown was cancelled by user message
            try {
              const checkResponse = await fetch(`/api/conversation/${currentSessionId}`);
              const checkData = await checkResponse.json();
              
              if (!checkData.countdown || checkData.countdown <= 0) {
                // User sent a message, countdown was cancelled
                console.log('‚èπÔ∏è Countdown cancelled - user sent message');
                countdownCancelled = true;
                clearInterval(countdownInterval);
                endSessionTimeout = null;
                warnBtn.textContent = originalText;
                warnBtn.disabled = false;
                
                // Show notification to librarian
                alert('‚èπÔ∏è Countdown cancelled - User sent a message. Please continue assisting them.');
                
                // Refresh to show new messages
                refreshConversation();
                return;
              }
            } catch (error) {
              console.error('Error checking countdown:', error);
            }
            
            countdown--;
            warnBtn.textContent = `Ending in ${countdown}s...`;
            
            // Update countdown status on server
            if (countdown > 0) {
              try {
                await fetch('/api/librarian/set-countdown', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    sessionId: currentSessionId,
                    countdown: countdown
                  })
                });
              } catch (error) {
                console.error('Error updating countdown:', error);
              }
            }
            
            if (countdown <= 0 && !countdownCancelled) {
              // Double-check one more time before closing
              try {
                const finalCheckResponse = await fetch(`/api/conversation/${currentSessionId}`);
                const finalCheckData = await finalCheckResponse.json();
                
                if (!finalCheckData.countdown || finalCheckData.countdown <= 0) {
                  // User sent a message at the last second!
                  console.log('‚èπÔ∏è Countdown cancelled at last second - user sent message');
                  clearInterval(countdownInterval);
                  endSessionTimeout = null;
                  warnBtn.textContent = originalText;
                  warnBtn.disabled = false;
                  
                  alert('‚èπÔ∏è Countdown cancelled - User sent a message. Please continue assisting them.');
                  refreshConversation();
                  return;
                }
              } catch (error) {
                console.error('Error in final countdown check:', error);
              }
              
              clearInterval(countdownInterval);
              endSessionTimeout = null;
              warnBtn.textContent = originalText;
              warnBtn.disabled = false;
              
              // Automatically end the session
              endSessionAutomatically();
            }
          }, 1000);
          
          // Store the interval so it can be cancelled if needed
          endSessionTimeout = countdownInterval;
        } else {
          alert('Error sending warning: ' + data.error);
        }
      } catch (error) {
        alert('Error sending warning: ' + error.message);
      }
    }

    async function endSessionAutomatically() {
      if (!currentSessionId) return;

      try {
        const response = await fetch('/api/librarian/end-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId: currentSessionId })
        });

        const data = await response.json();
        
        if (data.success) {
          closeModal();
          loadNotifications(); // Refresh the list
        } else {
          console.error('Error ending session:', data.error);
        }
      } catch (error) {
        console.error('Error ending session:', error.message);
      }
    }

    async function endSession() {
      if (!currentSessionId) return;
      
      if (!confirm('End this session? The user will be returned to the AI assistant.')) {
        return;
      }

      try {
        const response = await fetch('/api/librarian/end-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId: currentSessionId })
        });

        const data = await response.json();
        
        if (data.success) {
          alert('Session ended. User has been returned to the AI assistant.');
          closeModal();
          loadNotifications(); // Refresh the list
        } else {
          alert('Error ending session: ' + data.error);
        }
      } catch (error) {
        alert('Error ending session: ' + error.message);
      }
    }

    // Allow Enter to send (Shift+Enter for new line)
    document.addEventListener('DOMContentLoaded', () => {
      const input = document.getElementById('response-input');
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendResponse();
        }
      });
    });

    // Auto-refresh every 2 seconds
    setInterval(loadNotifications, 2000);
    
    // Initial load
    loadNotifications();
    loadCannedResponses();
  </script>
</body>
</html>
